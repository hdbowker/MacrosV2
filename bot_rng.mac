|**
----------------------------
BOT_RNG.mac
----------------------------
This macro is configured for use by only the ranger class
Modify the BOT_RNG_CHARNAME.ini file for use by a specific toon
This was written ground up for usage with xiris's bots
    
Usage: /mac bot_rng ${intTankID} ${intAssistHP} ${RV_healpoint} ${RV_secondassist}
______________________________________________
REVISION HISTORY
    12.03.15    xiris INITIAL REVISION
	10.27.16	xiris ADDED Buffing from external include	
	11.22.16	xiris REMOVED Range attack 'cause it's useless post POP
	09.17.18    xiris   Included ALL xiris bot libraries in common instead of in individual macros
	04.16.22	xiris	Overhauled group heal method and variable names
						Moved commons healing functions to the include	
______________________________________________
REQUIRED PLUGINS
    mq2cast
    mq2eqbc
    mq2debuffs
    mq2moveutils

______________________________________________
REQUIRED INCLUDES 
	xiris_common/xiris_common.inc
**|

#include xiris_common/xiris_common.inc

#Turbo 40

#event AutoFireOn      		"#*#AutoFire on#*#"
#event AutoFireOff     		"#*#AutoFire off#*#"

Sub InitEvents_Class
	/call RegisterClassEvents Events_RNG 2
/return

Sub Events_RNG
	/doevents AutoFireOn
	/doevents AutoFireOff
/return 

Sub Main(string _tank1Name, string _tank2Name, string _tank3Name, int _healPoint, string _assistArgs)
	/echo This line and the next here because calling a macro from a macro ...
	/echo ... apparently causes problems for the first line in the second macro
	/echo You are now in xiris_bot_${Me.Class.ShortName}.mac [I learned this from E3!~]

	|-- initialize the common xbot libraries
	/call xbot_initialize ${_tank1Name} ${_tank2Name} ${_tank3Name} ${_healPoint} ${_assistArgs}

	|-- initialize the macro specific libraries
	/call variant_initialize

	|-- report my status
	/bc [${Me.Class.ShortName}] ${Me.Name} ${str_action} >> ${Spawn[${_tank1Name}].CleanName} <<

	|-- target the MT
	/call TrueTarget ${int_MTID}

	|**
	----------------------------
	Main Loop
	----------------------------
	Runs in order listed,
	if adding any routine add the call here
	----------------------------
	**|

	:MainLoop
    /if (${Me.Casting.ID} && ${Me.Hovering}||${Window[tradewnd].Open}||${Window[lootwnd].Open}) /goto :MainLoop
	
		|-- Check to make sure MT is still alive, if not, find another
		/call chkMTAlive FALSE
		
		|-- Check to see if self needs to be cured (xiris_curing.inc)
		/call RunAllEvents
		/call chkNeedCure
		
		|-- Check the to see if group needs healing (xiris_healing.inc)
		/call chkHeal_Group

		|-- Check Auto Assist if its on
		/if (${bln_autoAssist}) /call chkAutoAssist

		/if (${bln_engaged}) {
			|-- class specific
			/call chkConcussion

			|-- dps lib
			/call RunRaidEvents
    		/call RunClassEvents
			/call chkTarget
			/call chkTargetDist
			/call chkNuke
			
			|-- std library
			/call RunRaidEvents
    		/call RunClassEvents
			/call chkAAs
			/call chkBurn
			/call chkClicks
		}
	
		|-- check utilities, includes: sit,loot,leash (out of combat only)
		/if (!${bln_engaged}) {
			/call chkUtils
			/call chkDownshits
		}
	|-- start again	
	/call chkMobDead
    /goto :MainLoop
/return

|**
 ----------------------------
 Target Checking
 ----------------------------
 Determines if the main assist has a new target, and wether we can attack
 ----------------------------
**|
Sub chkTarget
	|-- Make sure I have the target
	/if (!${Target.ID} || ((${Target.ID} !=  ${int_targetID}) && ${int_targetID} !=0) && (${SpawnCount[npc id ${int_targetID}]} > 0) && (${Spawn[id ${int_targetID}].PctHPs} != 0)) /call TrueTarget ${int_targetID}
    |-- Check for Target Death
	:chkTargetDead
    /if ((!${Target.ID} || ${Target.Type.NotEqual[NPC]}) && ${bln_engaged}) {
		/echo Mob is dead. Engage off.
        /varset bln_engaged FALSE
		/varset int_targetID 0
		/stick off
		/melee reset
		/varset AssistStickDistance 25
		/goto :return
	}

	|-- Check to see if I am on HoTT
	:chkHoTT
    /if (${Me.TargetOfTarget.CleanName.Equal[${Me.CleanName}]} && !${meleeAggro}) {
		| Fire Riposte Disc on hard hitters
		/if (${Target.Name.Find[Pirik]} || ${Target.Name.Find[Yihst]} || ${Target.Name.Find[Tunat]}) {
			/call FireRiposteDisc
		}
		| If Riposting skip the rest
		/if (${bln_riposting}) /goto :return 

		| Stop attacking
		/echo pulled aggro, resetting for 2s
		/melee reset
		/delay 20
		/if (${Target.ID} && ${Target.Type.Equal[NPC]}) /killthis
	}
	:return
/return

|**
 ----------------------------
 Target Engage
 ----------------------------
 Engage the target
 ----------------------------
**|


Sub engageTarget(_targetID)
	/echo engageTarget ${Spawn[id ${_targetID}].CleanName} (${_targetID})
	/if (${_targetID} == 0) /return
	/varset int_targetID ${_targetID}
	/call TrueTarget ${int_targetID}
	/varset bln_engaged TRUE
	/killthis
	/attack on
	/call ResetCastTimers
	/call GetAssistStickDist
	/call StickToAssistTarget
/return

Sub targetReset
	/varset bln_engaged FALSE
	/stick off
	/melee reset
/return

|**
 ----------------------------
 Utility Checking
 ----------------------------
 Checks the utilities such as fail states (GM, Lobby, etc)
 Checks to see if we should med, loot, leash
 ----------------------------
**|
Sub chkUtils
	/call chkSit
	/call chkLoot
	/call chkLeash
/return

|**
 ----------------------------
 Direct Damage  
 ----------------------------
 Loops through the nuke list and applies
 ----------------------------
**|

Sub chkNuke
	/if (!${bln_engaged}) /return
	/if (${Me.Casting.ID} || ${Me.Moving} || ${Me.Invis}) /return
	/if (${int_nukeTotal} == 0) /return 
	/if (${Me.PctMana} < 1) /return
	
	/if (${Target.PctHPs}<=${int_nukeStartHP} && ${Target.ID} && ${Target.Type.Equal[NPC]} && ${Me.PctMana}>=${int_nukeMinMana}) {
	
		/declare k int local
		/for k 1 to ${int_nukeTotal}  
			:nukeStart
			|-- Check to see if this spell is ready, if not, goto next spell
			/if (!${Me.SpellReady[${Nuke_${k}}]}) {
				/if (${k} <= ${int_nukeTotal}) {
					/next k
					/goto :nukeStart
				} else {
					/return
				}
			}
			:nukeCastWait
			/if (${Me.Casting.ID}) {
				/delay 2
				/goto :nukeCastWait
			}
		
			/if (${Target.PctHPs}<=${Nuke_${k}_StartHP} && ${Target.PctHPs}>=${Nuke_${k}_StopHP}) {
				
				/if (${Me.CurrentMana}>=${Spell[${Nuke_${k}}].Mana} && ${Me.SpellReady[${Nuke_${k}}]} && ${Target.Distance}<=${Spell[${Nuke_${k}}].Range} && ${Target.LineOfSight} && ${Nuke_${k}_Use}) {
					/echo Current NUKE: ${Nuke_${k}}
					/call MQ2Cast "${Nuke_${k}}" ${Nuke_${k}_Gem} 5s
				}
			}
		
		/next k
	}
/return

|**
 ----------------------------
 Check Health Subroutinies
 ----------------------------
 Calls 2 subroutines, checking self and checking group.
 See bot_clr for more information
 checksRNG	(and heals)
 checksGRP	(and heals)
 ----------------------------
**|
 
 Sub chkHeal
	/if (${Me.PctMana} < 15) /return
	/call RunRaidEvents
    /call chkRNG
    /call chkGRP
	/if (${int_targetID} != 0 && ${bln_engaged}) {
		/target ${Spawn[id ${int_targetID}]}
		/killthis
	}
	
/return
 

 Sub chkRNG
	/if (${Me.PctHPs} <= ${int_point_selfNormal}) {
		/call healRNG
	}
	
 /return 
 
 Sub chkGRP
    /call HealGRP
/return

|**
 ----------------------------
 HealSelf
 ----------------------------
 Healing Logic for the ranger
 Determines which spell to cast, then casts it.
 ----------------------------
**|

Sub healRNG
	/varcalc 	int_point_calcStopHeal ${Math.Calc[${int_point_selfNormal}*1.1]}
	/varset 	int_currentHP		${Me.PctHPs}
	/keypress f1
	/varset str_currentHeal ${str_heal_normal}
	/echo healSELF ${int_MTID} ${Target.Name} "${str_heal_normal}"
	/call healCast ${Me.ID} ${Me.Name} "${str_heal_normal}"
	/varset int_point_calcStopHeal	${int_point_selfNormal}
/return


|**
 ----------------------------
 HealGroup
 ----------------------------
 Healing Logic for entire group.
 Determines which is the worst 'hurt' character, and heals based on what heal point to heal at.
 Called by the Cast logic on cast of a heal spell
 ----------------------------
**|
Sub healGRP
	/varcalc	int_point_calcStopHeal ${Math.Calc[${int_grpHealPoint}*1.1]}
	
	/declare	int_numDamaged	int	local	0
	/declare	int_worstHP		int	local	100
	/declare	int_worstID		int local	0
	/declare	int_minorHurt	int local	0
	/declare	int_majorHurt	int local	0
	/declare	gmember			int local	0
	/declare    str_worstName	string local NULL
	/declare	str_worstClass	string local NULL
	
	| -- Cycle through the group and set the worst HP
	/for gmember 0 to ${Group}
		/if ( (${Group.Member[${gmember}].Distance}<=${int_range_normal}) && ${Target.Type.Equal[PC]}) {
			/if (${Group.Member[${gmember}].PctHPs} < ${int_worstHP}) { 
				|/echo ${Group.Member[${gmember}].Name} ${Group.Member[${gmember}].Distance} :: ${int_range_normal} :: ${Group.Member[${gmember}].PctHPs}
				/varset int_worstID     	${Group.Member[${gmember}].ID} 
				/varset int_worstHP         ${Group.Member[${gmember}].PctHPs} 
				/varset str_worstName		${Group.Member[${gmember}].Name}
				/varset str_worstClass      ${Group.Member[${gmember}].Class.Name} 
			} 
		} 
        /if ((${Group.Member[${gmember}].Distance}<=${int_range_normal})&&(${Group.Member[${gmember}].PctHPs}<=${int_point_calcStopHeal})) /varcalc int_numDamaged ${int_numDamaged}+1 
        /if ((${Group.Member[${gmember}].PctHPs}<=${int_point_calcStopHeal})&&(${Group.Member[${gmember}].PctHPs}>=60))   /varcalc int_minorHurt ${int_minorHurt}+1 
        /if ((${Group.Member[${gmember}].PctHPs}<=${int_point_calcStopHeal})&&(${Group.Member[${gmember}].PctHPs}< 60))   /varcalc int_majorHurt ${int_majorHurt}+1 
    /next gmember
	/if ((${int_worstHP} > ${int_point_calcStopHeal}) || ${int_worstHP} == 0 ) /return
	
	/varset int_currentHP ${int_worstHP}
	
	/echo ${str_worstName} being healed!
	| -- Cast the set heal	
	/varset str_currentHeal ${str_heal_normal}
	/echo HealGroupMember ${int_MTID} ${Target.Name} "${str_currentHeal}"
	/call healCast ${int_worstID} ${str_worstName} "${str_currentHeal}"
	
	/varset int_point_calcStopHeal	${int_grpHealPoint}
/return


|**
 ----------------------------
 Debuffing  
 ----------------------------
 Loops through the debuff list and applied
 Currently ghetto and will just cast debuff 1
 ----------------------------
**|


|**
 ----------------------------
 Concussion  
 ----------------------------
 If Concussion counter is hit, Concussion to kill aggro
 ----------------------------
**|
Sub chkConcussion
	/if (!${bln_engaged} || ${Me.Invis}||${Me.Moving}||!${bln_concUse}) /return 
	
	|/echo chkConcussion ${bln_concUse} ${timer_concDelay}
	/if (${bln_concUse} && ${Me.Standing} && ((${timer_concDelay}==0) || ${Me.TargetOfTarget.Name.Equal[${Me.Name}]})) {
		/call chkSpellMemorized "${str_concSpell}" ${str_concGem} TRUE
		/call MQ2Cast "${str_concSpell}" ${str_concGem}
		/varset timer_concDelay ${timer_concDelay.OriginalValue}
		/varset int_concCount 0
	}
/return

|**
 ----------------------------
 Sit/Med Checking
 ----------------------------
 This macro burns a lot of endurance if configured right, so sit whenever able
 ----------------------------
**|
Sub chkSit
    /if ( ${Me.PctMana}<=85 && !${Me.Combat} && (${SpawnCount[npc radius 75 zradius 55]} == 0)) {
        /if (!${Me.Sitting}) /sit on
        /delay 2s
    } else {
        /if (${Me.Sitting}) /sit off
    }
/return





|**
 ----------------------------
 INITIALIZATION Sub
 ----------------------------
 Initialization of values for this specific macro variant
 ----------------------------
**| 
Sub variant_initialize

	|-- set up default vars
	/declare    str_action				string	outer	Assisting	
	/memspellset default
	
	|-- set up ranger specific variables
	/declare	bln_preEngaged			bool	outer	FALSE
	/declare	bln_snared				bool	outer	FALSE
	/declare	timer_nuke				timer	outer	0
	/declare	timer_dot				timer	outer	0
	/declare	timer_hail				timer	outer	0
	/declare	timer_sit				timer	outer	0
	/declare	int_prevSpell			int		outer	0
	/declare	str_excludes			string	outer
	
	|--Archery
	/declare	bln_archeryAuto			bool	outer	TRUE
	/declare	bln_autoFireState		bool	outer	FALSE
	/declare	int_archeryDist			int		outer	${Ini[botINI,Settings,archeryDist,200]}
	
	|--Concussion
	/declare bln_concUse				bool	outer 	${Ini[botINI,Concussion,bln_concUse,TRUE]}
	/declare bln_concAggro				bool	outer 	${Ini[botINI,Concussion,bln_concAggro,FALSE]}
	/declare int_concCountActive		int		outer	${Ini[botINI,Concussion,int_concCountActive,5]}
	/declare str_concSpell				string	outer   ${Ini[botINI,Concussion,str_concSpell,Concussion]}
	/declare str_concGem				string	outer   ${Ini[botINI,Concussion,str_concGem,alt]}
	/declare timer_concDelay			timer	outer   ${Ini[botINI,Concussion,timer_concDelay,5s]}
	

	|--Hail of Arrows
	|  note: not available in POP
	/declare bln_useHail				bool	outer	${Ini[botINI,HailOfArrows,bln_hailofarrows,FALSE]}
	/declare str_hailSpell				string	outer	${Ini[botINI,HailOfArrows,str_hailSpell,Barrage of Arrows]}
	/declare int_hailAt					int		outer	${Ini[botINI,HailOfArrows,int_hailAt,95]}
	/declare int_hailStop				int		outer	${Ini[botINI,HailOfArrows,int_hailStop,10]}
	/declare int_hailDelay				int		outer	${Ini[botINI,HailOfArrows,int_hailDelay,320]}
	
	|--Snaring
	/declare bln_snareUse				bool	outer	${Ini[botINI,Snare,bln_snareUse,FALSE]}
	/declare int_snareHP				int		outer	${Ini[botINI,Snare,int_snareHP,35]}
	/if (!${Defined[str_snareSpell]}) /declare str_snareSpell string	outer	${Ini[botINI,Snare,str_snareSpell,Atol's Spectral Shackles]}
	/varset str_snareSpell	${Ini[botINI,Snare,str_snareSpell,Atol's Spectral Shackles]}
	/declare str_snareGem				string	outer   ${Ini[botINI,Snare,str_snareSpell,alt]}
	/declare int_snareLocalNPC			int		outer	${Ini[botINI,Snare,int_snareLocalNPC,99]}
	/declare bln_snareActive			bool	outer	FALSE
	/declare int_snareCounter			int		outer	0
	
	
	/memspellset default
	/cecho \at${Me.Class.Name} Loaded: MT: ${str_MTName}(${int_MTID})HealPoint:${int_point_tankNormal} SAName: ${str_tankName2}(${int_STID})
	/call InitEvents_Class
/return



Sub Event_AutoFireOn
	/varset bln_autoFireState TRUE
/return

Sub Event_AutoFireOff
	/varset bln_autoFireState FALSE
/return



