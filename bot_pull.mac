|**
----------------------------
BOT_PULL.mac
----------------------------
This macro is configured for use by an SK, but may work for any class
Modify the BOT_PULL_zoneinfo.ini file for use in a specific zone
A great majority of this code has been repurposed from several 
excellent macros by PeteSampras, Fry, et al

______________________________________________
REVISION HISTORY
    09.16.10    xiris  	Initial Revision
    10.07.10	xiris  	Added Polygon Bounding (removed later as unecessary)
    11.07.15	xiris  	Hacked this together to just use fartaunting for specific mobs
	07.23.17    xiris  	Fixed alert list 2 (target hunter)
	07.14.18	xiris  	Removed fartaunt due to server banning it
	11.18.21	xiris	Added mq2nav for pulling now that emulator mq2 has it
	12.01.21	xiris	Added some tweaked events around pulling (NOLOS/TOOCLOSE) to handle weird edge cases
	01.17.22	xiris	Added support for buff lines in chkBuffs, see xiris_buffing_lines.inc
	04.10.22	xiris	Normalized arguments
	05.24.22	xiris	Reworked the pulling sub - gained performance
	05.28.22	xiris	Refactored /docommand /${cmdChannel} to be consistent globally
______________________________________________
REQUIRED PLUGINS
    mq2melee
    mq2cast
    mq2eqbc
    mq2debuffs
    mq2moveutils
	mq2nav
______________________
REQUIRED INCLUDES 
	xiris_common/spell_routines.inc
	xiris_common/xiris_common.inc <-- which has a ton of includes!
**|


#include xiris_common/xiris_common.inc

#Turbo 40

#define INI_zoneInfo xiris_common/xiris_pull_zoneinfo.ini

#event RageOff              "#*#is no longer enraged#*#"
#event RageOn               "#*#has become ENRAGED#*#"
#event Zoned                "You have entered#*#"
#event Zoned                "LOADING, PLEASE WAIT..."
#event NoLOS				"#*#you cannot see your target#*#"
#event TooClose				"#*#your target is too close#*#"

Sub Main(int _pull_dist, string _channel, string _announce, int _campCount, bool _useDownFlags)
	/delay 5

	|-- initialize common xbot variables
	/call xbot_initialize ${Me.Name}
	
	|-- initialize variables specific to this macro
	/call variant_initialize ${_pull_dist} ${_channel} ${_announce} ${_campCount} ${_useDownFlags}

	|-- report status
	/echo Pulling >> ${Zone.Name} @ ${int_maxRadius} Range<<

	|-- set base alerts for this camp
	/call setAlerts
	
	/melee aggro=on
	
	|**
	 ----------------------------
	 Main Loop
	 ----------------------------
	 If adding any routine add the call here
	 Runs in order
	 ----------------------------
	**|
	:MainLoop
		/if (${MacroQuest.GameState.Equal[CHARSELECT]} || ${MacroQuest.GameState.Equal[PRECHARSELECT]} ) /end
		/if (${Me.Casting.ID} && ${Me.Hovering}||${Window[tradewnd].Open}||${Window[lootwnd].Open}) /goto :mainLoop
		
		|-- Check to see if self needs to be cured (xiris_curing.inc)
		/call RunAllEvents
		/call chkNeedCure

		/call chkUtils
		/if (${useDownFlags}) /call chkDownshits
		
		/call chkZone
		
		|-- reset group to camp spot (leash) if its empty
		/if (${SpawnCount[npc radius ${int_campRadius} zradius 25]} == 0) {
			/call resetCamp
			/docommand /${cmdChannel} refreshXTarget
			/docommand /${cmdChannel} //varset bln_engaged FALSE
			/hidecorpse npc
		}
		
		|-- run the pull/kill segment
		:getAndKill
			/call getTarget
			/if (${Target.Distance} > 20) /call pullTarget
			/if (!${Target.ID}) /goto :getAndKill
			/if (${Target.ID}) /call killTarget
			
			/echo We have killed ${int_killCount} mobs

	/goto :MainLoop
/return

Sub chkZone
	/if (${Zone.ShortName.NotEqual[${SZ_shortName}]}) {
		/if (${Zone.ShortName.Equal[GuildLobby]}) {
			/docommand /${cmdChannel}  I died! GTFO! ${Time}
			/delay 5s
			/docommand /${cmdChannel}  //dzquit
			/delay 10s
			/docommand /${cmdChannel}  offtankon
			/end
		}
	}
/return


Sub setRSTVars
	/varset	bln_validTGT	FALSE
	/varset bln_TGTDead		TRUE
	/varset bln_TGTLocal	FALSE
	/target clear
/return


Sub setTGTAlert
	/echo setTGTAlert ${Target.ID} ${Target.Name}
	/alert add 1 id ${Target.ID}
	/keypress esc
/return

|**
 ----------------------------
 getTarget
 ----------------------------
 Checks to see if there are any mobs within camp, if so, it targets them indiscriminately
 otherwise, it attempts to target a NPC that does not fall in the alert list
 Calls chkTarget once a target has been found, if that returns as valid, it continues
 ----------------------------
**|
Sub getTarget
	/echo getTarget
	/if (${Me.Sitting}) /sit off

	:AcquireLoop
		| set the vars like target validity to FALSE so we can check
		/call setRSTVars
		/squelch /target clear
		
		|----------USE THIS FOR SPECIFIC HUNTER (ALERT 2) --------
		/if (${SpawnCount[npc radius ${int_campRadius} zradius 15]} > 0) {
			/echo NPC in camp, killing
			/call TrueTarget ${NearestSpawn[npc radius ${int_campRadius} zradius 15].ID} 
			/delay 5
		} else /if (${SpawnCount[npc alert 2 radius ${int_alert2Radius} range ${int_minTLevel} ${int_maxTLevel}]} > 0) {
			/echo NPC on alert 2 is up, killing
			/call TrueTarget ${NearestSpawn[npc range ${int_minTLevel} ${int_maxTLevel} radius ${int_alert2Radius} alert 2].ID}
			/delay 5
		} else /if (${SpawnCount[npc alert 2 radius ${int_alert2Radius} range ${int_minTLevel} ${int_maxTLevel}]} == 0 && ${SpawnCount[npc noalert 1]} > 0) {
			/echo No NPCs on the alert 2 list are up, trying random NPC
			/call TrueTarget ${NearestSpawn[npc range ${int_minTLevel} ${int_maxTLevel} radius ${int_maxRadius} noalert 1].ID} 
			/delay 5
		} 

		/if (${Target.ID} && (${Target.Distance} <= ${int_campRadius})) {
			|--if it is close, its valid;
			/varset bln_validTGT	TRUE
		} else {
			|--check the target
			/if (${Target.ID}) /call chkTarget
		}
		
		
		|--restart if there is no valid target
		/if (!${bln_validTGT}) {
			|-- if there is more than 1 camp in our dataset, we can start walking through the camps
			/if (${int_campCount} > 1) {
					/echo Checking on Moving the Camp
					:MoveCamp
					|-- if we are less than the current camp and we are incrementing, move forward
					/if (${int_currentCamp} == ${int_campCount}) {
						/varset bln_increment FALSE
					} else /if (${int_currentCamp} == 1) {
						/varset bln_increment TRUE
					}

					/if (${bln_increment}) {
						/varset int_currentCamp ${int_currentCamp}+1
						/docommand /${cmdChannel} Incrementing Camp to ${int_currentCamp}
					} else {
						/varset int_currentCamp ${int_currentCamp}-1
						/docommand /${cmdChannel} Decrementing Camp to ${int_currentCamp}
					}
				
					/call moveCamp ${int_currentCamp}
					/delay 10
			} else {
				/echo no valid target delaying 5s
				/delay 5s
			}
			/goto :AcquireLoop
		}

		|--target is valid, continue
		/varset int_targetID 	${Target.ID}
		/varset bln_TGTDead		FALSE
		/varset int_distTGT 	${Int[${Target.Distance}]}
		/echo Acquired ${Target.Name} at range ${Int[${Target.Distance}]}
/return

|**
 ----------------------------
 chkTarget
 ----------------------------
 Checks to see if the current target passes the criteria
 If it is a valid target, bln_validTGT is assigned TRUE
 Returns to getTarget
 ----------------------------
**|
Sub chkTarget
	/echo chkTarget ${Target.Name}
	/if (${Target.Type.NotEqual[NPC]}) /return
	
	|--check if there is a path to the target
	/if (!${Navigation.PathExists[target]}) {
		/echo INVALID No Path to Target
		/call setTGTAlert
		/return
	}
	
	|--check my target is the apropriate level
	/if ((${Target.ID}) && (${Target.Level} < ${int_minTLevel})) {
		/echo INVALID Target.Level
		/call setTGTAlert
		/return
	}
	/if (${Target.Underwater} && ${Zone.ShortName.NotEqual[powater]}) {
		/echo INVALID Target.Underwater
		/call setTGTAlert
		/return
	}
	
	|--check my target is the above the apropriate z-radius floor
	/if ((${Target.ID}) && ${Int[${Target.Z}]}<${int_minZHeight}) { 
		/echo INVALID Target.Z
		/call setTGTAlert
		/return
	} 
	|--check my target is the above the apropriate z-radius ceiling
	/if ((${Target.ID}) &&${Int[${Target.Z}]}>${int_maxZHeight}) { 
		/echo INVALID Target.Z
		/call setTGTAlert
		/return
	}
	
	/varset bln_validTGT	TRUE
/return 

Sub setCamp
	/echo Setting camp at camp${int_currentCamp} out of ${int_campCount}
	/navigate RecordWaypoint bot_pull_nav
	
	/varset D1X int outer ${Me.X}
	/varset D1Y int outer ${Me.Y}
	/varset D1Z int outer ${Me.Z}

	/varset int_campY ${Me.Y}
	/varset int_campX ${Me.X}
	/delay 1s
	|/mqpause on
/return

Sub moveCamp(int _campNumber) 
	/echo Moving to Camp ${_campNumber}
	/docommand /${cmdChannel} //nav wp camp${_campNumber}
	/delay 1
	:moveCampNavLoop
		/echo moveCampNavLoop
		/if (${Navigation.Active}) {
			/delay 1s
			/goto :moveCampNavLoop
		} 
	/call setCamp
/return


|**
 ----------------------------
 pullTarget
 ----------------------------
 Checks to see if we need to pull target, if so, then we initiate the pulling mechanism
 and then once aggro is established, drags the mob back to camp to be killed
 Calls AggroTarget
 Calls makecamp return
 Returns to mainLoop if a valid pull has been achieved
 ----------------------------
**|
Sub pullTarget
	/echo pullTarget
	/declare campDist int local
	/declare dist int local
	|--check to see if we have a valid target, or skip
	/declare attempt int local 0

	
	:pullLoop
		/if (!${bln_validTGT}) 				/goto :return
		/if (!${Target.ID}) 				/goto :return
		/if (${Target.Type.NotEqual[NPC]}) 	/goto :return
	
		| Start the pull by running to the target
		:RunningToTarget
		/if (${Me.TargetOfTarget.Name.Equal[${Me.Name}]}) /goto :ReturnWithPull
		/if (${attempt} > 10) {
			/target clear
			/goto :ReturnWithPull
		} 
		/if (!${Target.ID}) /goto :return
		/if (!${Navigation.Active}) /navigate target
		/delay 10

		|-- Check to see if I don't yet have aggro
		:AggroCheck
		/if (!${Me.TargetOfTarget.ID} && (${Me.XTarget} < ${int_minPullCount})) {
			| I do not yet have aggro;
			:AggroDistCheck 
			| Am I close enough to aggro?
			/if (${Target.Distance} < ${int_castDistance} && ${Target.LineOfSight}) {
				| I am, call aggro sub.
				/call AggroTarget
				/varcalc attempt ${attempt} + 1
				/if (${Me.TargetOfTarget.Name.Equal[${Me.Name}]}) 	/goto :ReturnWithPull
				/if (${Macro.Return.Equal[NOLOS]})    				/goto :RunningToTarget
				/if (${Macro.Return.Equal[CAST_FIZZLE]})    		/goto :AggroCheck
				/if (${Macro.Return.Equal[NOTARGET]}) 				/goto :return
				/if (${Macro.Return.Equal[SUCCESS]})  {
					/doevents NoLoS 
					/if (${bln_noLOS}) {
						/varset bln_noLOS FALSE
						/goto :RunningToTarget
					} else {
						/goto :ReturnWithPull 
					}
				}
			} else {
				/goto :RunningToTarget
			}
		} else {
			| I have aggro, returning to camp
			:ReturnWithPull
			/cecho \agReturning to Camp with \ay${Me.XTarget}+ \agmobs.
			/navigate waypoint bot_pull_nav 
			
			:ReturnLoop
				/delay 10
				/varcalc dist ${Math.Distance[${Me.Y},${Me.X},${Me.Z}:${D1Y},${D1X},${D1Z}]}
				/if (${dist} < 50) /nav stop
				/if (${Navigation.Active})  /goto :ReturnLoop
		}
	:return
/return	



Sub AggroTarget 
	/if (${Navigation.Active}) /navigate stop
	/declare ret string local FAILED
	:TargetAggroCheck
	/if (!${Target.ID}) {
		/varset ret NOTARGET
	} else /if (!${Target.LineOfSight}) {
		/varset ret NOLOS
	} else /if (${Me.TargetOfTarget.Name.Equal[${Me.Name}]}) {
		/varset ret SUCCESS
	} else {
		| Need to aggro the mob somehow
		:AttemptAggro
		/if (${strPullType.Equal[RANGED]}) {
			/ranged
			/doevents TooClose
			|-- Sometimes if we aren't spell casting and using range weapons we might be too close, and cannot hit them with it.
			/if (${bln_tooClose}) {
				/echo Too Close! Handling
				/if (${Me.Class.ShortName.Equal[WAR]}) /call chk_warProvoke "${war_ca_hate_1}"
				/delay 1
				/if (${Me.CombatAbilityReady[Taunt]}) /doability Taunt
				/varset bln_tooClose FALSE
				/goto :TargetAggroCheck
			}
			/delay 10
			/goto :TargetAggroCheck
		} else {
			/call chkSpellMemorized "${spell_pull}" TRUE ${spell_pullGem}
			/echo ${Me.SpellReady[${spell_pull}]} Cast "${spell_pull}" ${spell_pullGem} 2s
			/call MQ2Cast "${spell_pull}" ${spell_pullGem} 2s
			/if (${Macro.Return.Equal[CAST_SUCCESS]}) /varset ret SUCCESS
			/if (${Macro.Return.Equal[CAST_CANNOTSEE]}) /varset ret NOLOS
			/if (${Macro.Return.Equal[CAST_INTERRUPTED]}) /goto :AttemptAggro
		} 
	}
	:return
/return ${ret}

|**
 ----------------------------
 Wait for the mob to be within kill/stick range, then issue
 /killthis command to mq2melee
 Calls chkCombatState while in the combatLoop
 ----------------------------
**|

Sub killTarget
	/if (!${Target.ID} || ${Target.Type.Equal[PC]}) /return
	/if (!${bln_validTGT}) /return
	/if (${bln_TGTDead})   /return
	/if (${Navigation.Active}) /navigate stop
	
	|--check camp distance
	:campCheck
	/if (${Math.Distance[${Me.Y},${Me.X}:${int_campY},${int_campX}]} > ${int_campRadius}) {
		/if (!${Navigation.Active}) /navigate waypoint bot_pull_nav
		/echo moving back to camp
		/delay 5
		/goto :campCheck
	} else {
		/if (${Navigation.Active}) /navigate stop
	}

	|--check the distance, if its out of melee range/aggro range, lets wait a second
	/face fast
	/declare int_waited int local 0
	:distanceWaitLoop
		/varcalc int_waited ${int_waited}+1
		/if (${int_waited} > 15) /return
		/if (!${Target.ID}) 	 /return
		/delay 5
		/if (${Target.Distance} > ${int_campRadius}) {
			/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) {
				/echo Something already in camp, changing target
				/target radius ${int_campRadius} npc
				/varset int_targetID ${Target.ID}
				/varset bln_validTGT	TRUE
				/delay 5
				/goto :killMob
			} else {
				/echo  Distance not covered! ${Target.Distance}::${int_waited} ${Target.Distance} > ${int_campRadius}
				/delay 5
				/goto :distanceWaitLoop
			}
		}
		
	:killMob
	|--issue kill command
	/varcalc int_killCount ${int_killCount}+1
	|TODO: make kill command use cmd chanenl
	/docommand /${announceChannel} KillMob ${Target.ID} "${Target.Name}" ${Time.Time24}
	/call ResetCastTimers
	/killthis
	/attack on
	/g Called Kill ${Target.ID} ${Target.Name} ${Time.Time24}
	
	/if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[SHD]}  && ${Me.SpellReady[${spell_aehate}]} ) {
		/echo ${Me.SpellReady[${spell_aehate}]} Cast ${spell_aehate} ${spell_aehateGem} 5s
		/call MQ2Cast "${spell_aehate}" ${spell_aehateGem}
	}
	
	/if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[WAR]} && ${Me.CombatAbilityReady[Area Taunt]}) {
		/doability "Area Taunt"
	} else /if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[WAR]} && ${Me.AltAbilityReady[Rampage]}) {
		/call MQ2Cast "Rampage" alt
	}
	
	
	/if (!${Me.Combat}) {
		/killthis
	}

	
	|--while in combat do these things
	:combatLoop
		/call chkCombatState
		/if (${int_targetID} != ${Target.ID}) /return
		/if (${Target.Type.NotEqual[NPC]}) /return
		/if (${Target.Distance} > ${int_campRadius}) /goto :distanceWaitLoop 

		/if (!${bln_TGTDead}) {
			/if ((${Me.TargetOfTarget.ID} != ${Me.ID}) && !${Target.Fleeing}) {
				/if ((${Me.Class.ShortName.Equal[SHD]} || ${Me.Class.ShortName.Equal[PAL]}) && ${Me.SpellReady[${spell_hate}]}) {
					/call MQ2Cast "${spell_hate}" ${spell_hateGem}
				} else /if (${Me.Class.ShortName.Equal[WAR]} && (${Me.CombatAbilityReady[${war_ca_hate_1}]})) {
					/doability "${war_ca_hate_1}"
				} else /if (${Me.Class.ShortName.Equal[WAR]} && (${Me.CombatAbilityReady[${war_ca_hate_2}]})) {
					/doability "${war_ca_hate_2}"
				} 
			} 
			/if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[SHD]}  && ${Me.SpellReady[${spell_aehate}]} ) {
				/echo ${Me.SpellReady[${spell_aehate}]} Cast ${spell_aehate} ${spell_aehateGem} 5s
				/call MQ2Cast "${spell_aehate}" ${spell_aehateGem}
			}
			/goto :combatLoop
		} else {
			/echo target is dead, return
		}
/return

Sub EngageTarget(_targetID) 
/return


|**
 ----------------------------
 chkCombatState
 ----------------------------
 A determination call, to see if current target is dead, or otherwise not
 a valid target anymore
 ----------------------------
**|
Sub chkCombatState
	/if (${Target.Type.NotEqual[NPC]}) 		 /varset bln_TGTDead TRUE
	/if (${Target.Type.Equal[Item]})		 /varset bln_TGTDead TRUE
	/if (!${Target.ID}) 					 /varset bln_TGTDead TRUE
	/if (${bln_TGTDead} && ${SpawnCount[npc radius ${int_campRadius}]} == 0 && ${bln_lootAuto}) /call chkLoot
/return



|**
 ----------------------------
 chkUtils
 ----------------------------
 Here we check mana of the cleric & the puller
 Here we check the endurance of the puller
 Here we check the hitpoints of the puller

 ----------------------------
**|

Sub chkUtils
	/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
	/varset bln_wait4Mana	FALSE
	/varset	bln_wait4End	FALSE
	/varset bln_wait4HP		FALSE

	/echo chkUtils

	:chkUtilLoop
		
		|/call chkBuffs
		|/call chkMana
		|/call chkEndurance
		/call chkHP
		/call chkComponentsAll
			
		/if (${bln_wait4Mana} || ${bln_wait4End} || ${bln_wait4HP}) {
			/echo Waiting for : mana: ${bln_wait4Mana} endurance: ${bln_wait4End} hitpoints: ${bln_wait4HP}
			/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
			/if (!${Me.Sitting}) /sit on 
			/delay 50
			/goto :chkUtilLoop
		}
		/if (${Me.Sitting}) /sit off
/return


Sub chkMana
	/varset bln_wait4Mana FALSE
	/if ((${int_groupCLRidx} != -1) && (${Group.Member[${int_groupCLRidx}].PctMana} < ${int_clrManaFloor})) {
		/echo Cleric mana ${Group.Member[${int_groupCLRidx}].PctMana} < ${int_clrManaFloor}
		/varset bln_wait4Mana TRUE
	}
	/if ( (${int_groupENCidx} != -1) &&  (${Group.Member[${int_groupENCidx}].PctMana} < ${int_encManaFloor})) {
		/echo Enc mana ${Group.Member[${int_groupENCidx}].PctMana} < ${int_clrManaFloor}
		/varset bln_wait4Mana TRUE
	}
	
	/if (${strPullType.Equal[SPELL]} && (${Me.PctMana} <  ${int_myManaFloor})) {
		/echo  ${strPullType} My mana ${Me.PctMana} < ${int_clrManaFloor}
		/varset bln_wait4Mana TRUE
	}
	
	|-- I don't think you can check the mana of an out of group member without netbots, so ignore it
	|/if (${int_localENCidx} != -1) {
		|/target ID ${int_localENCidx}
		|/delay 10
		|/if (${Target.PctMana} < ${int_encManaFloor})
		|/varset bln_wait4Mana TRUE
	|}	
	
/return


Sub chkEndurance
	/varset bln_wait4End FALSE
	/if (${Me.PctEndurance} < ${int_myEnduranceFloor}) 	/varset bln_wait4End TRUE
/return

Sub chkHP
	/varset bln_wait4HP FALSE
	/if (${Me.PctHPs} < ${int_myHitpointFloor}) 	/varset bln_wait4HP TRUE
/return

Sub chkBuffs

	/echo ----
	/echo Checking Buffs
	/echo IDs    ENC:${int_groupENCidx} CLR: ${int_groupCLRidx} DRU: ${int_groupDRUidx} SHM:${int_groupSHMidx}
	/echo Timers ENC:${timer_buffENC} CLR: ${timer_buffCLR} DRU: ${timer_buffDRU} SHM:${timer_buffSHM}
	/echo ----
	/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
	
	/declare int_wait 		int 	local 0
	/declare hasBuffLine 	bool 	local FALSE
	/declare groupList		string  local
	/call 	 composeGroupList |
	/varset  groupList ${Macro.Return}
	
	|-- check to see if there is a cleric and I haven't bugged them for at least a minute
	/if ((${int_groupCLRidx} != -1) && (${timer_buffCLR} == 0)) {
		|-- if there is a druid, then we want SYMBOL, else, AEGO
		/if (${int_groupDRUidx} != -1) {
			|-- there is an available druid (highly unlikely) so lets ask for SYMBOL if I don't have it
			/call chkHasBuffLine SYMBOL ${Me.Name}
			/varset hasBuffLine ${Macro.Return}
			/if (!${hasBuffLine}) {
				/g Requesting SYMBOL from ${str_groupCLRname}
				/bct ${str_groupCLRname} requestBuffLine SYMBOL GROUP ${groupList}
				/varcalc int_wait ${int_wait} + 10
				/varset timer_buffCLR 10m
			}
		} else {
			|-- there isn't an available druid so lets ask for AEGO if I don't have it
			/call chkHasBuffLine AEGO ${Me.Name}
			/if (!${hasBuffLine}) {
				/g Requesting AEGO from ${str_groupCLRname}
				/bct ${str_groupCLRname} requestBuffLine AEGO GROUP ${groupList}
				/varcalc int_wait ${int_wait} + 10
				/varset timer_buffCLR 10m
			}
		}
	}
	
	
	|-- check to see if there is an echanter
	/if ((${int_groupENCidx} != -1) && (${timer_buffENC} == 0)) {
		|-- Check for Haste
		/call chkHasBuffLine ENC_HASTE ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting ENC_HASTE from ${str_groupENCname}
			/bct ${str_groupENCname} requestBuffLine ENC_HASTE GROUP ${groupList}
			/varcalc int_wait ${int_wait} + 10
			/varset timer_buffENC 10m
		}
		|-- Check for Crack
		/call chkHasBuffLine CRACK ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting CRACK from ${str_groupENCname}
			/bct ${str_groupENCname} requestBuffLine CRACK GROUP ${groupList}
			/varcalc int_wait ${int_wait} + 10
			/varset timer_buffENC 10m
		}
	}
	
	|-- check to see if there is a druid
	/if ((${int_groupDRUidx} != -1) && (${timer_buffDRU} == 0)) {
		|-- Check for NINE
		/call chkHasBuffLine NINE ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting NINE from ${str_groupDRUname}
			/bct ${str_groupDRUname} requestBuffLine NINE GROUP ${groupList}
			/varset int_wait ${int_wait} + 10
			/varset timer_buffDRU 10m
		}
		|-- Check for DS
		/call chkHasBuffLine DRU_DS ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting DRU_DS from ${str_groupDRUname}
			/bct ${str_groupDRUname} requestBuffLine DRU_DS GROUP ${groupList}
			/varset int_wait ${int_wait} + 10
			/varset timer_buffDRU 10m
		}
	}
	
		|-- check to see if there is a cleric and I haven't bugged them for at least a minute
	/if ((${int_groupSHMidx} != -1) && (${timer_buffSHM} == 0)) {
		|-- if there is a druid, then we can skip haste, else, SHM_HASTE
		/if (${int_groupENCidx} != -1) {
			/call chkHasBuffLine SHM_HASTE ${Me.Name}
			/varset hasBuffLine ${Macro.Return}
			/if (!${hasBuffLine}) {
				/g Requesting SHM_HASTE from ${str_groupSHMname}
				/bct ${str_groupSHMname} requestBuffLine SHM_HASTE GROUP ${groupList}
				/varcalc int_wait ${int_wait} + 10
				/varset timer_buffSHM 10m
			}
		}
		|-- check for STR
		/call chkHasBuffLine FOCUS ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting STR from ${str_groupSHMname}
			/bct ${str_groupSHMname} requestBuffLine STR GROUP ${groupList}
			/varcalc int_wait ${int_wait} + 10
			/varset timer_buffSHM 10m
		}
		|-- check for STA
		/call chkHasBuffLine STA ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting STA from ${str_groupSHMname}
			/bct ${str_groupSHMname} requestBuffLine STA GROUP ${groupList}
			/varcalc int_wait ${int_wait} + 10
			/varset timer_buffSHM 10m
		}
		|-- check for AGI
		/call chkHasBuffLine AGI ${Me.Name}
		/varset hasBuffLine ${Macro.Return}
		/if (!${hasBuffLine}) {
			/g Requesting AGI from ${str_groupSHMname}
			/bct ${str_groupSHMname} requestBuffLine AGI GROUP ${groupList}
			/varcalc int_wait ${int_wait} + 10
			/varset timer_buffSHM 10m
		}
	}
	
	
	/echo Waiting ${int_wait}s for buffs
	/delay ${int_wait}s
	

	
/return


|**
 ----------------------------
 setSupportIDs
 ----------------------------
 Here we set the id of the group's cleric and other support classes.
 If we are in a raid setup, we handle that too as a 'local ID' instead of 'group ID'
 ----------------------------
**|
sub setSupportIDs
	/if (${useGroup}) {
		/declare gmember int local 0
		/for gmember 0 to ${Group}
			|-- Cleric
			/if (${Group.Member[${gmember}].Class.ShortName.Equal[CLR]}) {
				/echo Setting int_groupSHMidx to ${gmember}
				/varset int_groupCLRidx ${gmember}
				/varset str_groupCLRname ${Group.Member[${gmember}].Name}
			} else /if (${Group.Member[${gmember}].Class.ShortName.Equal[ENC]}) {
				/echo Setting int_groupENCidx to ${gmember}
				/varset int_groupENCidx ${gmember}
				/varset str_groupENCname ${Group.Member[${gmember}].Name}
			} else /if (${Group.Member[${gmember}].Class.ShortName.Equal[DRU]}) {
				/echo Setting int_groupDRUidx to ${gmember}
				/varset int_groupDRUidx  ${gmember}
				/varset str_groupDRUname ${Group.Member[${gmember}].Name}
			} else /if (${Group.Member[${gmember}].Class.ShortName.Equal[SHM]}) {
				/echo Setting int_groupSHMidx to ${gmember}
				/varset int_groupSHMidx ${gmember}
				/varset str_groupSHMname ${Group.Member[${gmember}].Name}
			}
		/next gmember
		
		|-- Friendly warning
		/if (${int_groupCLRidx} == -1) {
			/beep
			/echo !! WARNING !! No Cleric Found, you are brave!
		}
	} else {
		|-- Raid looping not implemented yet because I am lazy
	}

/return 




Sub chkComponents
	/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
	/if (${FindItemCount[=${item_pull_clean}]}>=50) /return
	/if (${strPullType.Equal[SPELL]}) /return

	/echo Pull Component: ${item_pull_clean} Count:${FindItemCount[=${item_pull_clean}]}
	
	:chkComponent
	/autoinv
	/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
	
	/if (${FindItemCount[=${item_pull_clean}]}>=200) /return
	
	/if (${FindItemCount[=${item_summon}]}>0) {
	/echo ${FindItemCount[=${item_summon}]}
		/echo ${item_summon} summoning ${item_pull_clean}
		:summon_item
		/call MQ2Cast "${item_summon}"
		/delay 50
		/autoinv
		/goto :chkComponent
	}
	
/return	
		
|**
 ----------------------------
 resetCamp
 ----------------------------
 Before each pull session, tell everyone to go back to the current camp
 ----------------------------
**|

Sub resetCamp
	/docommand /${cmdChannel} //nav wp camp${int_currentCamp}
/return

|**
 ----------------------------
 Initialization
 ----------------------------
 Here we declare variables
 Eventually this needs to be pulled from an INI per zone and per puller!
 ----------------------------
**|
Sub variant_initialize(int _pull_dist, string _channel, string _announce, int _campCount, bool _useDownFlags)
	|--loot
	/varset bln_lootAuto			FALSE
	/if (${bln_lootAuto}) 			/call EnableLooting

	|--downflags 
	/declare useDownFlags	bool	outer	TRUE
	/if (${Defined[_useDownFlags]} && !${_useDownFlags}) /varset useDownFlags FALSE
	
	|--melee plugin/aggro for the requester
	/melee aggro=on
	/docrack preventspeed on
	/declare useGroup	bool	outer	FALSE
	
	|--command channel setup
	/if (!${Defined[cmdChannel]}) /declare cmdChannel string	outer	bcga
	/varset cmdChannel bcga
	/if (${Defined[_channel]}) /varset cmdChannel ${_channel}
	/echo 	cmdChannel is ${cmdChannel}
	/docommand /${cmdChannel}	//speed 1.25

	|--announce channel set
	/if (!${Defined[announceChannel]}) /declare announceChannel string	outer	bcga
	/varset announceChannel bcga
	/if (${Defined[_announce]}) /varset announceChannel ${_announce}
	/echo announceChannel is ${announceChannel}
	/docommand /${cmdChannel}	//speed 1.25

	
	|--camp counts
	/declare int_currentCamp		int		outer	1
	/declare int_campCount			int 	outer	1
	/declare bln_increment 			bool	outer	TRUE
	/if (${Defined[_campCount]}) {
		/varset int_campCount ${_campCount}
	}	

	|--set up the camp logic
	/if (!${Defined[int_campX]}) /declare int_campX 				int outer ${Me.X}
	/if (!${Defined[int_campY]}) /declare int_campY 				int outer ${Me.Y}
	/if (!${Defined[int_campZ]}) /declare int_campZ 				int outer ${Me.Z}

	/declare D1X int outer ${Me.X}
	/declare D1Y int outer ${Me.Y}
	/declare D1Z int outer ${Me.Z}

	|--set the camp spot
	/call setCamp

	|--radii
	/declare int_pcCount			int 	outer   ${SpawnCount[PC]}
	/declare int_campRadius			int		outer	50
	/declare int_maxRadius			int		outer	425
	/if (${Defined[_pull_dist]}) {
		/varset int_maxRadius ${_pull_dist}
	}
	
	|--how far we can go for alert 2 mobs (note, seperate from maxRadius)
	/declare int_alert2Radius		int 	outer 	2050

	|-- use 40 for POFire
	/declare int_minZHeight			int		outer 	0
	/declare int_maxZHeight			int		outer	250
	/varcalc int_minZHeight		${Me.Z} - 100
	/varcalc int_maxZHeight		${Me.Z} + 200

	|--target information
	/declare int_minPullCount		int		outer   3
	/declare int_minTLevel			int		outer	40
	/declare int_maxTLevel			int		outer	73
	/declare bln_validTGT			bool	outer	FALSE
	/declare bln_TGTDead			bool	outer	FALSE
	/declare bln_TGTLocal			bool	outer	FALSE
	/declare int_distTGT			int		outer	0
	/declare int_distTGTPredict		int		outer	0
	/declare int_alertCount			int		outer	0
	/declare int_killCount			int		outer	0
	
	|--utility floors
	/declare int_myHitpointFloor	int		outer	60
	/declare int_myEnduranceFloor	int		outer	0
	|-- note my mana floor only matters if I am a spell casting puller
	/declare int_myManaFloor		int		outer	20 
	/declare int_clrManaFloor		int		outer	20
	/declare int_encManaFloor		int		outer	0
	/declare bln_wait4Mana			bool	outer	FALSE
	/declare bln_wait4HP			bool	outer	FALSE
	/declare bln_wait4End			bool	outer	FALSE
	
	|--spell & support definitions are declared in xiris_melee.inc
	/declare timer_taunt            timer 	outer    3s

	|--set the puller type 
	/declare strPullType	string	outer	RANGED
	
	| MELEE DPS CLASS ENUMERATION - Endurance Focus
	/if (${Select[${Me.Class.ShortName},ROG,BER,MNK]}) {
		/varset strPullType RANGED
	}
	
	| MELEE DPS CLASS ENUMERATION - Mana Focus
	/if (${Select[${Me.Class.ShortName},BST,RNG,BRD]}) {
		/varset strPullType RANGED
	}	
	
	| TANK CLASS ENUMERATION
	/if (${Select[${Me.Class.ShortName},WAR]}) {
		/varset strPullType RANGED
	}		
	
	| TANK CASTER CLASS ENUMERATION
	/if (${Select[${Me.Class.ShortName},SHD,PAL]}) {
		/varset strPullType SPELL
	}	
	
	| MANUAL SETTING VIA TOON NAME HERE
	/if (${Me.Name.Equal[Sadelia]}) /varset strPullType RANGED

	
	/declare int_obstacleCNT		int 	outer 	0
	/declare bln_noLOS				bool	outer	FALSE	
	/declare bln_tooClose			bool	outer	FALSE
	
	|--find the support members of the group for use in keeping up buffs
	/declare int_groupCLRidx int outer -1
	/declare int_localCLRid int outer -1
	/declare str_groupCLRname string outer NULL
	/declare timer_buffCLR timer	outer  1s

	/declare int_groupENCidx int outer -1
	/declare int_localENCid int outer -1
	/declare str_groupENCname string outer NULL
	/declare timer_buffENC timer	outer  1s
	
	/declare int_groupDRUidx int outer -1
	/declare int_localDRUid int outer -1
	/declare str_groupDRUname string outer NULL
	/declare timer_buffDRU timer	outer  1s

	/declare int_groupSHMidx int outer -1
	/declare int_localSHMid int outer -1
	/declare str_groupSHMname string outer NULL
	/declare timer_buffSHM timer	outer 1s
		
	/call setSupportIDs
	
/return


Sub setAlerts
	|=================================
	|--- specific zone mobs to avoid;
	|=================================
	/squelch /alert clear 1
	/squelch /alert add 1 "a young dire wolf"
	/squelch /alert add 1 "All Powerful Gnome"
	/squelch /alert add 1 "Guardian of Doomfire"
	/squelch /alert add 1 "The Fabled Kobold Noble"
	/squelch /alert add 1 "The Fabled Kobold Priest"
	/squelch /alert add 1 "The Fabled Kobold Champion"
	/squelch /alert add 1 "The Fabled Solusek Kobold King"
	/squelch /alert add 1 "The Fabled Death Beetle"
	/squelch /alert add 1 "fire giant warrior"
	/squelch /alert add 1 "neiroth"
	/squelch /alert add 1 "zordak ragefire"
	/squelch /alert add 1 "lord nagafen"
	/squelch /alert add 1 "magus rokyl"
	/squelch /alert add 1 "fire giant wizard"
	/squelch /alert add 1 "Warlord Skarlon"
	/squelch /alert add 1 "King Tranix"
	/squelch /alert add 1 "GREEmoteTrap"
	/squelch /alert add 1 "The Wailing Sister"
	/squelch /alert add 1 "Hatchling"
	/squelch /alert add 1 "Hedge Trigger"
	/squelch /alert add 1 "Odaen"
	/squelch /alert add 1 "Ptav M'sha"
	/squelch /alert add 1 "Dvoin M'sha"
	/squelch /alert add 1 "Mnat M'sha"
	/squelch /alert add 1 "Aganetti the Keeper"
	/squelch /alert add 1 "Cynosure Kvanjji"
	/squelch /alert add 1 "Qkav`d the Fourth Arbitor"
	/squelch /alert add 1 "Svi`pral the Second Arbitor"
	/squelch /alert add 1 "Vishai the First Arbitor"
	/squelch /alert add 1 "Ytvagi the Third Arbitor"
	/squelch /alert add 1 "General Reparm"
	/squelch /alert add 1 "General Druav Flamesinger"
	/squelch /alert add 1 "Blazzax the Omnifiend"
	/squelch /alert add 1 "Pyronis"
	/squelch /alert add 1 "Magmaton"
	/squelch /alert add 1 "Arch Mage Yozanni"
	/squelch /alert add 1 "Councilman"
	/squelch /alert add 1 "Pixtt"
	/squelch /alert add 1 "Mass of Stone"
	/squelch /alert add 1 "Zelnithak"
	/squelch /alert add 1 "remains of vah"
	/squelch /alert add 1 "a guardian spirit"
	/squelch /alert add 1 "spectre of corruption"
	/squelch /alert add 1 "barban"
	/squelch /alert add 1 "Tantisala"
	/squelch /alert add 1 "Pixtt Uxnikk"
	/squelch /alert add 1 "Pixtt Kekken"
	/squelch /alert add 1 "A Kyv Runner"
	/squelch /alert add 1 "Gamesh"
	/squelch /alert add 1 "Scribe Gurru"
	/squelch /alert add 1 "an enslaved yunjo"
	/squelch /alert add 1 "etumer"
	/squelch /alert add 1 "the wailing sister"
	/squelch /alert add 1 "untel"
	/squelch /alert add 1 "Warder Cecilia"
	/squelch /alert add 1 "Zun`Muram Votal"
	/squelch /alert add 1 "Pixtt Votal"
	/squelch /alert add 1 "Packmaster Skoiat Pizak"
	/squelch /alert add 1 "a hungry yunjo"
	/squelch /alert add 1 "Smith Rondo"
	/squelch /alert add 1 "Caridwi"
	/squelch /alert add 1 "a waiting warder"
	/squelch /alert add 1 "a yunjo"
	/squelch /alert add 1 "Velketor"
	/squelch /alert add 1 "a hissing"
	/squelch /alert add 1 "the walls"
	/squelch /alert add 1 "a chill"
	/squelch /alert add 1 "a massive burrower"
	/squelch /alert add 1 "The Burrower Beast"
	/squelch /alert add 1 "Trydan Faye"
	/squelch /alert add 1 "Rhalliq Trell"
	/squelch /alert add 1 "Alekson Garn"
	/squelch /alert add 1 "a bitten victim"
	/squelch /alert add 1 "a petrified colossal tree"
	/squelch /alert add 1 "a hollow tree"
	/squelch /alert add 1 "a trap"
	/squelch /alert add 1 "flavor text"
	/squelch /alert add 1 "ten"
	/squelch /alert add 1 "six"
	/squelch /alert add 1 "two"
	/squelch /alert add 1 "a hissing"
	/squelch /alert add 1 "four"
	/squelch /alert add 1 "eight"
	/squelch /alert add 1 "three"
	/squelch /alert add 1 "ten"
	/squelch /alert add 1 "TerrorSpawner"
	/squelch /alert add 1 "a shimmering orb"
	/squelch /alert add 1 "aedispellph"
	/squelch /alert add 1 "aerainph"
	/squelch /alert add 1 "from no where"
	/squelch /alert add 1 "mini named controller"
	/squelch /alert add 1 "the hair"
	/squelch /alert add 1 "a murkglider licheglider"
	/squelch /alert add 1 "a murkglider soulstalker"
	/squelch /alert add 1 "Ixt Imnes the Ironhoof"
	/squelch /alert add 1 "Ikaav Salisa Mexmielk"
	/squelch /alert add 1 "Dragorn Champion"
	/squelch /alert add 1 "Filligno the Slayer"
	/squelch /alert add 1 "a creaking crate"
	/squelch /alert add 1 "Taromani"
	/squelch /alert add 1 "Chailak"
	/squelch /alert add 1 "Feratha"
	/squelch /alert add 1 "Turlini"
	/squelch /alert add 1 "Narundel"
	/squelch /alert add 1 "Ranguali"
	/squelch /alert add 1 "Namosa"
	/squelch /alert add 1 "Nerask"
	/squelch /alert add 1 "a ferocious chimera"
	/squelch /alert add 1 "Manaetic Behemoth"
	/squelch /alert add 1 "Trydan Faye"
	/squelch /alert add 1 "Alekson Garn"
	/squelch /alert add 1 "Rhaliq Trell"
	/squelch /alert add 1 "Planar Projection"
	/squelch /alert add 1 "a norrathian maiden"
	/squelch /alert add 1 "villager"
	/squelch /alert add 1 "an erudite villager"
	/squelch /alert add 1 "a ogre villager"
	/squelch /alert add 1 "a high elf villager"
	/squelch /alert add 1 "a dwarf villager"
	/squelch /alert add 1 "a gnome villager"
	/squelch /alert add 1 "a human villager"
	/squelch /alert add 1 "a troll villager"
	/squelch /alert add 1 "a portal crystal"
	/squelch /alert add 1 "kenra"
	/squelch /alert add 1 "irak"
	/squelch /alert add 1 "Gazak"
	/squelch /alert add 1 "Maroley"
	
	|=================================
	|--- specific zone mobs to hunt;
	|=================================
	/squelch /alert clear 2
	|--Hunter Cycle--|
	/squelch /alert add 2 "froglok hunter"
	/squelch /alert add 2 "Oracle Froskil"
	/squelch /alert add 2 "Harbinger Josk"
	/squelch /alert add 2 "Knight Dragol"
	/squelch /alert add 2 "Vessel Fryn"
	/squelch /alert add 2 "Keeper Sepsis"
	/squelch /alert add 2 "Ebon lotus"
	/squelch /alert add 2 "Ffroaak"
	/squelch /alert add 2 "Dreadlord Dekir"
	/squelch /alert add 2 "Partisan Yinlen"
	/squelch /alert add 2 "Doom"
	/squelch /alert add 2 "Throkkok"
	/squelch /alert add 2 "Hierophant Ixyl"
	/squelch /alert add 2 "Master Fasliw"
	/squelch /alert add 2 "Sigra"

	|-- Forager Cycle--|
	/squelch /alert add 2 "froglok forager"
	/squelch /alert add 2 "Champion Thenrin"
	/squelch /alert add 2 "Commander Sils"
	/squelch /alert add 2 "Titail Sinok"
	/squelch /alert add 2 "Bloodeye"
	/squelch /alert add 2 "Dreadlord Fanrik"
	/squelch /alert add 2 "Hangman"
	/squelch /alert add 2 "Dragontail"
	/squelch /alert add 2 "Squire Glik"
	/squelch /alert add 2 "Klok Denris"
	/squelch /alert add 2 "Crusader Zoglic"
	/squelch /alert add 2 "Harbinger Dronik"
	/squelch /alert add 2 "Keeper Lasnik"
	/squelch /alert add 2 "Silvermane"
	/squelch /alert add 2 "Thruke"
	/squelch /alert add 2 "Flayhte"
	/squelch /alert add 2 "Champion Arlek"
	/squelch /alert add 2 "froglok_hunter"
	/squelch /alert add 2 "Oracle Froskil"
	/squelch /alert add 2 "Harbinger Josk"
	/squelch /alert add 2 "Knight Dragol"
	/squelch /alert add 2 "Vessel Fryn"
	/squelch /alert add 2 "Keeper Sepsis"
	/squelch /alert add 2 "Ebon lotus"
	/squelch /alert add 2 "Ffroaak"
	/squelch /alert add 2 "Dreadlord Dekir"
	/squelch /alert add 2 "Partisan Yinlen"
	/squelch /alert add 2 "Doom"
	/squelch /alert add 2 "Throkkok"
	/squelch /alert add 2 "Hierophant Ixyl"
	/squelch /alert add 2 "Master Fasliw"
	/squelch /alert add 2 "Sigra"
	
	|-- Anguish Signets--|
	/squelch /alert add 2 "turncoat"
	/squelch /alert add 2 "mastermind"
	
	|-- LDON Hunter
	| /squelch /alert add 2 "Keeper of Blood" |note spawns in spot you can't nav to
	/squelch /alert add 2 "Yavrin"
	
	|-- etc--|
	/squelch /alert add 2 "night watchman"
	/squelch /alert add 2 "officiator"
	/squelch /alert add 2 "Ulyist"
	/squelch /alert add 2 "Keeper of Blood"
	/squelch /alert add 2 "Yavrin"
	/squelch /alert add 2 "Bial the Blade"
	/squelch /alert add 2 "Jerrand"
	/squelch /alert add 2 "Sikl"
	/squelch /alert add 2 "Giddib"
	/squelch /alert add 2 "officiator"

	
	/squelch /alert clear 3
	/squelch /alert add 3 "All Powerful Gnome"

/return

Sub Event_TooClose
	/echo Event_TooClose
	/varset bln_tooClose TRUE
	/doevents flush TooClose
/return

Sub Event_NoLOS
	/echo Event_NoLOS
	/varset bln_noLOS TRUE
	/doevents flush NoLOS
/return


Sub Event_EndMac
	/docommand /${cmdChannel} Someone told me to end it! ${Time}
	/delay 1s
	/docommand /${cmdChannel}  //melee off
	/docommand /${cmdChannel}  //end
	/docommand /${cmdChannel}  //gate
	/delay 2m
	/docommand /${cmdChannel}  //end
	/docommand /${cmdChannel}  //melee off
	/docommand /${cmdChannel}  //camp desktop
	/docommand /${cmdChannel}  //end
	/end
/return
