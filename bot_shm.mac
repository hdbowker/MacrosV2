|**
----------------------------
BOT_SHM.mac
----------------------------
This macro is configured for use by the SHAMAN class
Modify the BOT_CLS_CHARNAME.ini file for use by a specific toon
This was written ground up for usage with xiris's bots.

Usage: /mac bot_shm ${_tank1Name} ${_tank2Name} ${_healPoint} ${_assistArgs}

______________________________________________
REVISION HISTORY
	09.27.16	xiris	INITIAL REVISION
	10.24.16	xiris 	Moved Buffing to external include
	11.14.16	xiris 	Added support for an exclude list (see xiris_common for include)
	11.11.17	xiris   Added support for removal of mq2melee
	09.17.18    xiris   Included ALL xiris bot libraries in common instead of in individual macros
	12.22.21	xiris	Cleaned up some of the healing to bring inline with clerics
	01.02.22	xiris	Modified a bit to work a little smoother 
	04.05.22 	xiris	Added new Events aggregator and handlers
	04.16.22	xiris	Overhauled group heal method and variable names
						Moved commons healing functions to the include
______________________________________________
REQUIRED PLUGINS
    mq2cast
    mq2eqbc
    mq2debuffs
    mq2moveutils
    
______________________________________________
REQUIRED INCLUDES  
	xiris_common/xiris_common.inc
**|

#include xiris_common/xiris_common.inc

#turbo 40

#EVENT DOSHRINK "<#1#> doShrink#*#"
#EVENT DOSHRINK "[#1#(msg)] doShrink#*#"
#EVENT DOSHRINK "#1# tells you, 'doShrink#*#'"
#EVENT DOSHRINK "#1# tells the group, 'doShrink#*#'"
#EVENT DOSHRINK "#1# you tell your party, 'doShrink#*#'"

Sub InitEvents_Class
	/call RegisterClassEvents Events_SHM 1
/return

Sub Events_SHM
	/doevents DOSHRINK
/return 

Sub Main(string _tank1Name, string _tank2Name, string _tank3Name, int _healPoint, string _assistArgs)
	/echo This line and the next here because calling a macro from a macro ...
	/echo ... apparently causes problems for the first line in the second macro
	/echo You are now in xiris_bot_${Me.Class.ShortName}.mac [I learned this from E3!~]

	|-- initialize the common xbot libraries
	/call xbot_initialize ${_tank1Name} ${_tank2Name} ${_tank3Name} ${_healPoint} ${_assistArgs}

	|-- initialize the macro specific libraries
	/call variant_initialize

	|-- report my status
	/bc [${Me.Class.ShortName}] ${Me.Name} ${str_action} >> ${Spawn[${_tank1Name}].CleanName} <<  @ ${int_point_tankNormal} ${_assistArgs}

	|-- target the MT
	/call TrueTarget ${int_MTID}
	|**
	| ----------------------------
	| Main Loop
	| ----------------------------
	| Runs in order listed,
	| if adding any routine add the call here
	| ----------------------------
	|**|
	
	:MainLoop
		
		/if (${Me.Casting.ID} && ${Me.Hovering}||${Window[tradewnd].Open}||${Window[lootwnd].Open}) /goto :MainLoop
		|-- Check to make sure MT is still alive, if not, find another
		/call chkMTAlive FALSE

		|-- Check to see if self needs to be cured (xiris_curing.inc)
		/call RunAllEvents
		/call chkNeedCure
		
		|-- Check the three main groupings of heal classes (xiris_healing.inc)
		/call chkHeal_MT
		/call chkHeal_Self
		/call chkHeal_Group
		
		|-- Check for out of combat buffs (xiris_buffing.inc)
		/call RunAllEvents
		/call chkOOCBuffs
		
		|-- Check for local targets (xiris_debuffing.inc)
		/if (${SpawnCount[NPC radius 85 range 50 100]} > 0) {
			|-- get a list of the local NPCs
			/call getTargets
		} else {
			/call targetReset
		}

		|-- Check Auto Assist if its on
		/if (${bln_autoAssist}) /call chkAutoAssist
		
		|-- If Engaged run DPS/ETC
		/if (${bln_engaged}) {
			/if (!${Target.ID} || ${Target.ID} != ${int_targetID} && ${int_targetID} !=0 && (${Spawn[id ${int_targetID}].PctHPs} != 0)) /call TrueTarget ${int_targetID}
			|-- class specific
			/call RunAllEvents
			/call chkPetAttack	
			/call chkChampion		
			
			|-- debuff lib
			/call RunAllEvents
			/call chkDebuffs
			
			|-- dps lib
			/call RunRaidEvents
    		/call RunClassEvents
			/call chkDOT
			/call chkNuke
			
			|-- std library
			/call RunRaidEvents
    		/call RunClassEvents
			/call chkAAs
			/call chkBurn
			/call chkClicks
			
			|-- check in combat buffs
			/call RunRaidEvents
    		/call RunClassEvents
			/call cmbtBuffGRP
		}
		
		|-- check utilities, includes: sit,loot,leash (out of combat only)
		/if (!${bln_engaged}) {
			/call chkUtils
			/call chkDownshits
		}
		
	|-- start again	
	/call chkMobDead
    /goto :MainLoop
/return		

|**
 ----------------------------
 Target Engage
 ----------------------------
 Engage the target, note usually triggered by EVENT_KILLMOB (see xiris_common.inc)
 ----------------------------
**|

Sub engageTarget(_targetID)
	/echo engageTarget ${Spawn[id ${_targetID}].CleanName} (${_targetID})
	/if (${_targetID} == 0) /return
	/varset int_targetID ${_targetID}
	/call TrueTarget ${int_targetID}
	/call Add2TargetArray ${_targetID}
	/varset bln_engaged TRUE
/return


Sub targetReset
	/varset bln_engaged 		FALSE
	/varset bln_petAttacking 	FALSE
	/pet hold on
	/call CleanTargetArray
/return


|**
 ----------------------------
 HealGroup
 ----------------------------
 Healing Logic for entire group.
 Determines which is the worst 'hurt' character, and heals based on what heal point to heal at.
 Called by the Cast logic on cast of a heal spell
 Note: There are variations between this and other PRIEST healGRP methods
 ----------------------------
**|
Sub healGRP
	/varcalc	int_point_calcStopHeal ${Math.Calc[${int_grpHealPoint}*1.1]}

	/declare	int_numDamaged	int	local	0
	/declare	int_worstHP		int	local	100
	/declare	int_worstID		int local	0
	/declare	int_minorHurt	int local	0
	/declare	int_majorHurt	int local	0
	/declare	gmember			int local	0
	/declare    str_worstName	string local NULL
	/declare	str_worstClass	string local NULL
	/declare 	tmr_HoT 		string local
	
	| -- Cycle through the group and set the worst HP
	/for gmember 0 to ${Group}
		/if ( (${Group.Member[${gmember}].Distance}<=${int_range_normal})) { 	
			/if (${Group.Member[${gmember}].PctHPs} < ${int_worstHP}) { 
				/varset int_worstID     	${Group.Member[${gmember}].ID} 
				/varset int_worstHP         ${Group.Member[${gmember}].PctHPs} 
				/varset str_worstName		${Group.Member[${gmember}].Name}
				/varset str_worstClass      ${Group.Member[${gmember}].Class.Name} 
			} 
		} 
        /if ((${Group.Member[${gmember}].Distance}<=${int_range_normal})&&(${Group.Member[${gmember}].PctHPs}<=${int_point_calcStopHeal})) /varcalc int_numDamaged ${int_numDamaged}+1 
        /if ((${Group.Member[${gmember}].PctHPs}<=${int_point_calcStopHeal})&&(${Group.Member[${gmember}].PctHPs}>=${int_point_grpPatch}))   /varcalc int_minorHurt ${int_minorHurt}+1 
        /if ((${Group.Member[${gmember}].PctHPs}<=${int_point_calcStopHeal})&&(${Group.Member[${gmember}].PctHPs}< ${int_point_grpPatch}))   /varcalc int_majorHurt ${int_majorHurt}+1 
    /next gmember

	| -- If no one needs healing...
	/if ((${int_worstHP} > ${int_point_calcStopHeal}) || ${int_worstHP} == 0 ) /return

	| -- Determine appropriate heal
	/varset int_currentHP ${int_worstHP}

	| -- Single Target Heal
	/if (${int_majorHurt} == 1) {
		/if (${int_worstHP} > ${int_point_grpPatch}) /return
		/echo PATCH single heal (Shaman only have 1 heal type here)
		/varset str_currentHeal ${str_heal_normal}
		/echo HealGroupMember ${int_MTID} ${Target.Name} "${str_currentHeal}"
		/call healCast ${int_worstID} ${str_worstName} "${str_currentHeal}"
	
	| -- Minor Heals (HoTs) - and HOT enabled;
	} else /if (${int_majorHurt} == 0 && ${use_heal_HoT}) {
		|-- Single Target HoT
		/if (${int_worstHP} > ${int_point_grpHot}) /return
		/if (!${Defined[timer_HoT_${Group.Member[${str_worstName}]}]}) /declare timer_HoT_${Group.Member[${str_worstName}]} timer outer 40s
		/varset tmr_HoT timer_HoT_${Group.Member[${str_worstName}]}

		/if (${${tmr_HoT}} == 0) {
			/echo setting timer HOT for member: ${Group.Member[${str_worstName}]} , ${str_worstName}
			/echo userHoT should be timer_HoT_${Group.Member[${str_worstName}]}
			|--if no timer, cast, and if sucess, set timer
			/varset	str_currentHeal		${str_heal_HoT}
			/echo HealGroupMember ${int_MTID} ${Target.Name} "${str_currentHeal}"
			/call healCast ${int_worstID} ${str_worstName} "${str_currentHeal}"
			
			/if (${Macro.Return.Equal["CAST_SUCCESS"]}) {
				/varset ${tmr_HoT} 40s
			}
		}

	}
/return



|**
 ----------------------------
 Cannibalization
 ----------------------------
 Applies Cannibalization if mana is below threshold
 ----------------------------
**|

Sub chkManaConvert
	/if (${Me.PctMana} < ${int_canniManaThreshold} && ${Me.SpellReady[${str_canniSpell}]} && ${Me.PctHPs} > ${int_canniHPThreshold}) {
		/echo "${str_canniSpell}"
		/call MQ2Cast "${str_canniSpell}" gem1 5s
	}
	
	/if (${Me.PctMana} < ${int_canniManaThreshold} && ${Me.AltAbilityReady[Cannibalization]} && ${Me.PctHPs} > ${int_canniHPThreshold}) {
		/echo AA "Cannibalization"
		/call MQ2Cast "Cannibalization" alt
	}
/return 

|**
----------------------------
Champion Checking
Champion is 1500 mana, so we don't want to cast it unless the timer is up
----------------------------  
**|

Sub chkChampion
	/if (!${bln_engaged}) /return
	/if (!${bln_useChampion}) /return
	/if (${timer_champion}) /return

	/call chkSpellMemorized "Champion" FALSE 7
	/if (!${Me.SpellReady[Champion]} && ${Me.SpellInCooldown[Champion]}) {
		| I must have just memmed champion, so uh, it takes 60s to be ready
		/varset timer_champion 60s
	} else {
		/call MQ2Cast "Champion"
		/varset timer_champion 510s
	}
/return



|**
 ----------------------------
 Utility Checking
 ----------------------------
 Checks the utilities such as fail states (GM, Lobby, etc)
 Checks to see if we should med, loot, leash
 note: these routines are defined in xiris_common for the most part
 ----------------------------
**|
Sub chkUtils
	|-- Shaman Specific
	/call chkManaConvert
	/call chkPet
	
	|-- Standard Methods
	/call chkSit
	/call chkLoot
	/call chkLeash
/return

Sub EVENT_DOSHRINK(line, ChatSender, eventParams)
	/echo \ay doShrinkEventCalled
	/if (${FindItemCount[Umbracite Swarm Orb]}) {
		/cecho \agShrinking
		/call MQ2Cast "Umbracite Swarm Orb" item
	}
/return


|**
 ----------------------------
 INITIALIZATION Subs
 ----------------------------
 Initialization of values for this specific macro variant
 ----------------------------
**|

Sub variant_initialize
	
	|-- set up default vars
	/declare    str_action				string	outer	Shamanizing	
	/memspellset default

	|-- Cannibalization
	/declare	int_canniManaThreshold	int		outer 	${Ini[botINI,Cannibalize,int_canni_mana_threshold,80]}
	/declare	int_canniHPThreshold	int		outer 	${Ini[botINI,Cannibalize,int_canni_hp_threshold,40]}
	/declare	str_canniSpell			string	outer 	${Ini[botINI,Cannibalize,str_canni_spell,Ancient:Chaotic Pain]}
	
	/cecho \at${Me.Class.Name} Loaded: MT: ${str_MTName}(${int_MTID})HealPoint:${int_point_tankNormal} SAName: ${str_tankName2}(${int_STID})
	/call InitEvents_Class
/return

