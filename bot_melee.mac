|**
----------------------------
BOT_MELEE.mac
----------------------------
This macro is configured for use by any melee class
Modify the BOT_CLS_CHARNAME.ini file for use by a specific toon
This was written ground up for usage with xiris's bots.
It heavily relies on mq2melee for specific class functionality.

Usage: /mac bot_melee ${_tank1Name} ${_tank2Name} ${_healPoint} ${_assistArgs}

______________________________________________
REVISION HISTORY
    06.16.10	xiris	INITIAL REVISION from PeteSampras
    10.12.10	xiris	Included a common include (common/xiris_common.inc) for subs and events
    10.13.10	xiris	Modification to remove some of the unused functionality
    10.15.10	xiris	Included burn routines
    10.21.10	xiris	Refactored the subs to be inline with global vars
	11.01.10	xiris	Reverted to using spell_routines.inc
						Modified the cast calls to use this.
	11.15.10	xiris	Modified some of the variable names
	09.04.15	xiris	Changed the variant_initialize to better handle the output from the loader
	10.23.15	xiris 	Rewrote to avoid using mq2melee
	11.19.15	xiris	MQ2melee was not cause of my crashes, putting it back in
	12.04.15	xiris 	Modified how the initialization of parameters works
	11.11.17	xiris   Added support for removal of mq2melee
	11.15.17	xiris   Reverted to use mq2melee (really does work better) for melee functions
	09.17.18    xiris   Included ALL xiris bot libraries in common instead of in individual macros
	12.22.21	xiris	Cleaned up some of the MT checking if inside own group
	02.25.22	xiris	Added support for Component check (berserker axes)
						Added support for Jolting (berserker disc)
	04.05.22 	xiris	Added new Events aggregator and handlers
	04.16.22	xiris	Cleaned up some older code, normalized all vars/name					
______________________________________________
REQUIRED PLUGINS
    mq2melee
    mq2cast
    mq2eqbc
    mq2debuffs
    mq2moveutils
    
______________________________________________
REQUIRED INCLUDES  
	xiris_common/xiris_common.inc
**|

#include xiris_common/xiris_common.inc

#Turbo 40

Sub InitEvents_Class
	/call RegisterClassEvents Events_AllMelee 0
/return

Sub Events_AllMelee
/return 

Sub Main(string _tank1Name, string _tank2Name, string _tank3Name, int _healPoint, string _assistArgs)
	/echo This line and the next here because calling a macro from a macro ...
	/echo ... apparently causes problems for the first line in the second macro
	/echo You are now in xiris_bot_${Me.Class.ShortName}.mac [I learned this from E3!~]

	|-- initialize the common xbot libraries
	/call xbot_initialize ${_tank1Name} ${_tank2Name} ${_tank3Name} ${_healPoint} ${_assistArgs}

	|-- initialize the macro specific libraries
	/call variant_initialize

	|-- report my status
	/bc [${Me.Class.ShortName}] ${Me.Name} ${str_action} >> ${Spawn[${_tank1Name}].CleanName} << 

	|-- target the MT
	/call TrueTarget ${int_MTID}

	|**
	----------------------------
	Main Loop
	----------------------------
	Runs in order listed,
	if adding any routine add the call here
	----------------------------
	**|

	:MainLoop
		/if (${Me.Casting.ID} && ${Me.Hovering}||${Window[tradewnd].Open}||${Window[lootwnd].Open}) /goto :MainLoop
	
		|-- Check to make sure MT is still alive, if not, find another
		/call chkMTAlive FALSE
		
		|-- Check Offtanking Situation (xiris_offtanking.inc)
		/call chkOffTanking
		
		|-- Check to see if self needs to be cured
		|   Note: method is in xiris_healing.inc
		/call RunAllEvents
		/call chkNeedCure
		
		|-- Check Auto Assist if its on
		/if (${bln_autoAssist}) {
			/call chkAutoAssist
		}
		
		/if (${bln_engaged}) {
			/if (!${Target.ID} || ${Target.ID} !=  ${int_targetID} && ${int_targetID} !=0 && (${SpawnCount[npc id ${_targetID}]} > 0) && (${Spawn[id ${int_targetID}].PctHPs} != 0)) /call TrueTarget ${int_targetID}
			|-- dps lib
			/call chkTarget
			/call chkTargetDist
			
			|-- std library
			/call RunRaidEvents
    		/call RunClassEvents
			/call chkAAs
			/call chkBurn
			/call chkClicks
		}

		|-- check utilities, includes: sit,loot,leash (out of combat only)
		/if (!${bln_engaged}) {
			/call chkUtils
			/call chkDownshits
		}

	|-- start again	
	/call chkMobDead
    /goto :MainLoop
/return

|**
 ----------------------------
 Target Checking
 ----------------------------
 Determines if the main assist has a new target, and whether we can attack
 ----------------------------
**|
Sub chkTarget
	|-- Check for Target Death
	:chkTargetDead
    /if ((!${Target.ID} || ${Target.Type.NotEqual[NPC]}) && ${bln_engaged}) {
		/echo Mob is dead. Engage off.
        /varset bln_engaged FALSE
		/varset int_targetID 0
		/stick off
		/melee reset
		/varset AssistStickDistance 25
		/goto :return
    }

	|-- Check to see if I am on HoTT
	:chkHoTT
	/if (${Me.TargetOfTarget.CleanName.Equal[${Me.CleanName}]} && !${meleeAggro}) {
		| Fire Riposte Disc on hard hitters
		/if (${Target.Name.Find[Pirik]} || ${Target.Name.Find[Yihst]} || ${Target.Name.Find[Tunat]}) {
			/call FireRiposteDisc
		}
		| If Riposting skip the rest
		/if (${bln_riposting}) /goto :return 

		/if (${Me.Class.ShortName.Equal[MNK]}) {
			/if (${Me.AbilityReady[Feign Death]}) /doability "Feign Death"
			/delay 5
			/stand on
			/goto :chkHoTT
		} else /if (${Me.Class.ShortName.Equal[BER]}) {
			/squelch /melee ragevolley=off
			/if (${Me.CombatAbilityReady[Baffling Strike]} && ${FindItemCount[Axe of the Destroyer]}>0) /disc Baffling Strike
			/if (${Me.CombatAbilityReady[Confusing Strike]} && ${FindItemCount[Rage Axe]}>0) /disc Confusing Strike
			/if (${Me.CombatAbilityReady[Distracting Strike]} && ${FindItemCount[Bonesplicer Axe]}>0) /disc Distracting Strike
			/delay 10
			/goto :chkHoTT
		} else /if (${Me.Class.ShortName.Equal[ROG]}) {	
			/if (${Me.CombatAbilityReady[Imperceptible Discipline]}) /disc Imperceptible Discipline
			/delay 10
			/goto :chkHoTT
		} else {
			/echo pulled aggro, resetting for 2s
			/melee reset
			/delay 20
			/if (${Target.ID} && ${Target.Type.Equal[NPC]}) /killthis
		}
	}

	|-- Check if I am burning, if so, Berserkers need to not rage volley, instead jolt
	:chkBerserker
	/if (${bln_BURNMode}) {
		/if (${Me.Class.ShortName.Equal[BER]}) {
			/squelch /melee ragevolley=off
			/if (${Me.CombatAbilityReady[Baffling Strike]} && ${FindItemCount[Axe of the Destroyer]}>0) /disc Baffling Strike
			/if (${Me.CombatAbilityReady[Confusing Strike]} && ${FindItemCount[Rage Axe]}>0) /disc Confusing Strike
			/if (${Me.CombatAbilityReady[Distracting Strike]} && ${FindItemCount[Bonesplicer Axe]}>0) /disc Distracting Strike
		}
	} else {
		|-- Not burning, turn RageVolley back on.
		/if (${Me.Class.ShortName.Equal[BER]}) {
			/squelch /melee ragevolley=30
		}
	}
	
	:return
/return

|**
 ----------------------------
 Target Engage
 ----------------------------
 Engage the target
 ----------------------------
**|

Sub engageTarget(_targetID)
	/echo engageTarget ${Spawn[id ${_targetID}].CleanName} (${_targetID})
	/if (${_targetID} == 0 || ${_targetID} == NULL) /return
	/if (${Me.Feigning} && (${Me.PctHPs} > 75)) /stand
	/varset int_targetID ${_targetID}
	/call TrueTarget ${int_targetID}
	/varset bln_engaged TRUE
	/call GetAssistStickDist
	/call StickToAssistTarget
	/killthis
	/attack on
/return


Sub targetReset
	/varset bln_engaged FALSE
	/stick off
	/melee reset
/return


|**
 ----------------------------
 Utility Checking
 ----------------------------
 Checks the utilities such as fail states (GM, Lobby, etc)
 Checks to see if we should med, loot, leash
 ----------------------------
**|
Sub chkUtils
	/call chkSit
	/call chkLoot
	/call chkLeash
	/if (${Me.Class.ShortName.Equal[BER]}) {
		|string _component, int _count, string _type, string _summonItem, string _reagent)
		/call chkComponentsAll
	}
/return



|**
 ----------------------------
 INITIALIZATION Sub
 ----------------------------
 Initialization of values for this specific macro variant
 ----------------------------
**| 
Sub variant_initialize
	|--Set Aggro
	/if (${str_tankName1.NotEqual[${Me.Name}]} && ${str_tankName2.NotEqual[${Me.Name}]}) {
		/melee aggro=0	
	} else {
		/melee aggro=1
	}

	|-- Set Common MQ2Melee settings
	/melee backoff=25
	/melee jolt=50
	/melee nodown=on
	/melee noholy=on
	/melee range=on
	/melee standup=on
	|-- set up default vars
	/declare    str_action				string	outer	Assisting	

	/cecho \at${Me.Class.Name} Loaded: MT: ${str_MTName}(${int_MTID})HealPoint:${int_point_tankNormal} SAName: ${str_tankName2}(${int_STID})
	/call InitEvents_Class
/return
