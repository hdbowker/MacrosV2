|**
----------------------------
BOT_DRU.mac
----------------------------
This macro is configured for use by the DRUID class
Modify the BOT_CLS_CHARNAME.ini file for use by a specific toon
This was written ground up for usage with xiris's bots.

Usage: /mac bot_dru ${_tank1Name} ${_tank2Name} ${_healPoint} ${_assistArgs}

______________________________________________
REVISION HISTORY
    12.04.15	xiris	INITIAL REVISION
	03.27.15	xiris	Added handlers for chchain (see xiris_healing.inc)
	10.27.16	xiris 	Moved Buffing to external include
	09.01.17	xiris 	Swapped some subs with the better written shaman versions
	09.17.18    xiris   Included ALL xiris bot libraries in common instead of in individual macros	
	12.22.21	xiris	Cleaned up some of the healing to bring inline with clerics
	04.05.22 	xiris	Added new Events aggregator and handlers
	04.16.22	xiris	Overhauled group heal method and variable names
						Moved commons healing functions to the include
______________________________________________
REQUIRED PLUGINS
    mq2cast
    mq2eqbc
    mq2debuffs
    mq2moveutils
    
______________________________________________
REQUIRED INCLUDES  
	xiris_common/xiris_common.inc
**|


#include xiris_common/xiris_common.inc

#turbo 40

Sub InitEvents_Class
	|/call RegisterClassEvents Events_DRU 0
/return

Sub Events_DRU

/return 

Sub Main(string _tank1Name, string _tank2Name, string _tank3Name, int _healPoint, string _assistArgs)
	/echo This line and the next here because calling a macro from a macro ...
	/echo ... apparently causes problems for the first line in the second macro
	/echo You are now in xiris_bot_${Me.Class.ShortName}.mac [I learned this from E3!~]

	|-- initialize the common xbot libraries
	/call xbot_initialize ${_tank1Name} ${_tank2Name} ${_tank3Name} ${_healPoint} ${_assistArgs}

	|-- initialize the macro specific libraries
	/call variant_initialize

	|-- report my status
	/bc [${Me.Class.ShortName}] ${Me.Name} ${str_action} >> ${Spawn[${_tank1Name}].CleanName} <<  @ ${int_point_tankNormal} ${_assistArgs}

	|-- target the MT
	/call TrueTarget ${int_MTID}

	|**
	----------------------------
	Main Loop
	----------------------------
	Runs in order listed,
	if adding any routine add the call here
	----------------------------
	**|
	
	:MainLoop
		/if (${Me.Hovering} || ${Window[tradewnd].Open} || ${Window[lootwnd].Open}) /goto :MainLoop
		|-- Check all Events
		/call RunAllEvents

		|-- Check to make sure MT is still alive, if not, find another
		/call chkMTAlive FALSE
		
		|-- Check to see if self needs to be cured (xiris_curing.inc)
		/call chkNeedCure

		|-- Check the three main groupings of heal classes (xiris_healing.inc)
		/call chkHeal_MT
		/call chkHeal_Self
		/call chkHeal_Group
		
		|-- Check for out of combat buffs
		/call RunAllEvents
		/call chkOOCBuffs

		|-- Check Auto Assist if its on
		/if (${bln_autoAssist}) /call chkAutoAssist
		
		/if (${bln_engaged}) {
			|-- check engaged events
			/call RunRaidEvents
			/call RunClassEvents

			|-- verify target status
			/call chkTarget	

			|-- debuff lib
			/call chkDebuffsOnSingleTarget ${int_targetID}
			
			|-- dps library (caster)
			/call RunRaidEvents
    		/call RunClassEvents
			/call chkDOT
			/call chkNuke
			
			|-- std library (burns/aa/clicks)
			/call RunRaidEvents
    		/call RunClassEvents
			/call chkAAs
			/call chkBurn
			/call chkClicks
		} else {
			|-- check utilities, includes: sit,loot,leash (out of combat only)
			/call chkUtils
			/call chkDownshits
		}
	|-- start again	
    /goto :MainLoop
/return	


|**
 ----------------------------
 HealGroup
 ----------------------------
 Healing Logic for entire group.
 Determines which is the worst 'hurt' character, and heals based on what heal point to heal at.
 Called by the Cast logic on cast of a heal spell
 Note: There are variations between this and other PRIEST healGRP methods
 ----------------------------
**|
Sub healGRP
	/varcalc	int_point_calcStopHeal ${Math.Calc[${int_grpHealPoint}*1.1]}

	/declare	int_numDamaged	int	local	0
	/declare	int_worstHP		int	local	100
	/declare	int_worstID		int local	0
	/declare	int_minorHurt	int local	0
	/declare	int_majorHurt	int local	0
	/declare	gmember			int local	0
	/declare    str_worstName	string local NULL
	/declare	str_worstClass	string local NULL
	
	| -- Cycle through the group and set the worst HP
	/for gmember 0 to ${Group}
		/if ( (${Group.Member[${gmember}].Distance}<=${int_range_normal})) { 	
			/if (${Group.Member[${gmember}].PctHPs} < ${int_worstHP}) { 
				/varset int_worstID     	${Group.Member[${gmember}].ID} 
				/varset int_worstHP         ${Group.Member[${gmember}].PctHPs} 
				/varset str_worstName		${Group.Member[${gmember}].Name}
				/varset str_worstClass      ${Group.Member[${gmember}].Class.Name} 
			} 
		} 
        /if ((${Group.Member[${gmember}].Distance}<=${int_range_normal})&&(${Group.Member[${gmember}].PctHPs}<=${int_point_calcStopHeal})) /varcalc int_numDamaged ${int_numDamaged}+1 
        /if ((${Group.Member[${gmember}].PctHPs}<=${int_point_calcStopHeal})&&(${Group.Member[${gmember}].PctHPs}>=${int_point_grpPatch}))   /varcalc int_minorHurt ${int_minorHurt}+1 
        /if ((${Group.Member[${gmember}].PctHPs}<=${int_point_calcStopHeal})&&(${Group.Member[${gmember}].PctHPs}< ${int_point_grpPatch}))   /varcalc int_majorHurt ${int_majorHurt}+1 
     /next gmember

	| -- If no one needs healing...
	/if ((${int_worstHP} > ${int_point_calcStopHeal}) || ${int_worstHP} == 0 ) /return

	| -- Determine appropriate heal
	/varset int_currentHP ${int_worstHP}

	| -- Single Target Heal
	/if (${int_majorHurt} >= 1) {
		/if (${int_worstHP} > ${int_point_grpPatch}) /return
		/echo PATCH single heal (Druid only have 1 heal type here)
		/varset str_currentHeal ${str_heal_normal}
		/echo HealGroupMember ${int_MTID} ${Target.Name} "${str_heal_normal}"
		/call healCast ${int_worstID} ${str_worstName} "${str_currentHeal}"
		/varset int_point_calcStopHeal	${int_point_selfNormal}
	}
/return


|**
 ----------------------------
 UTILITY Subs
 ----------------------------
 Things to do while OOC (or if in RAID)
 ----------------------------
**|   
Sub chkUtils
	|-- Standard Methods
	/call chkSit
	/call chkLoot
	/call chkLeash
/return

|**
 ----------------------------
 INITIALIZATION Subs
 ----------------------------
 Initialization of values for this specific macro variant
 ----------------------------
**|

Sub variant_initialize
	|-- set up default vars
	/declare    str_action				string	outer	Druiding	
	/memspellset default

	|-- set up class vars

	/cecho \at${Me.Class.Name} Loaded: MT: ${str_MTName}(${int_MTID})HealPoint:${int_point_tankNormal} SAName: ${str_tankName2}(${int_STID})
	/call InitEvents_Class
/return





