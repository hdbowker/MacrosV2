
#Turbo 10
#include xiris_common/xiris_common.inc

#Event brewval "Brewing:#1##2#"
#Event brewcheck "#*#brewcheck#*#"

#EVENT HanvarChainsOn		"#*#entangles you in chains#*#"
#EVENT HanvarChainsOff		"#*#You break free of the chains#*#"

Sub Main
	/declare timer_hanvar_stun 		timer 	outer 85
	/declare timer_hanvar_ae 		timer 	outer 360s
	/declare chainSeconds			int 	outer 0
	/declare stunSeconds			int   	outer 0	
	/declare int_timeChainOn 		int outer 	0
	/declare int_timeChainOff 		int outer	0
	/declare int_timeChainOn_1 		int outer	0
	/declare int_timeChainOn_2 		int outer 	0
	/declare int_timeChainInterval 	int outer   0
	
	/declare bln_announcedRetreat   bool    outer FALSE
	/declare timer_announce_retreat	timer   outer 0
	/declare timer_announce_chains	timer  	outer 0
	/declare timer_announce_guards	timer  	outer 0
	/declare timer_announce_kill 	timer  	outer 0	
	:loop
		/doevents
		/delay 10
		/cecho \aw${timer_hanvar_ae} \ag(\ao${chainSeconds}\ag) \aw1: \ag${int_timeChainOn_1} \aw2:  \ag${int_timeChainOn_2}
		|------
		| NPC/Hanvar Kills
		|------
		| Guards are up!
		/if (${SpawnCount[npc guard radius 150]}) {
			
			/if (!${timer_announce_guards}) /call commandAttackGuards
		} 
		
		| Run away!
		/if (${timer_hanvar_ae} <= 50 && !${bln_announcedRetreat}) {
			/if (!${timer_announce_retreat}) /call commandRetreat
		} 
		
		| Kill Hanvar
		/if (!${SpawnCount[npc guard radius 150]} && ${timer_hanvar_ae} > 50) {
			/if (!${timer_announce_kill}) /call commandAttackHanvar
		}

		/doevents
	/goto :loop
/return

| Hanvar fired his AE, safe to kill
Sub Event_HanvarChainsOn
	/cecho \arChains ON! \aw${Time.Time24} \ag${Time.SecondsSinceMidnight}
	/varset int_timeChainOn  ${Time.SecondsSinceMidnight} 
	/if (${int_timeChainOn_1} == 0) {
		/varset int_timeChainOn_1  ${Time.SecondsSinceMidnight}  
	} else /if (${int_timeChainOn_2} == 0) {
		/varset int_timeChainOn_1 ${int_timeChainOn_2}
		/varset int_timeChainOn_2  ${Time.SecondsSinceMidnight}  
	}
	/if (${int_timeChainOn_1} != 0 && ${int_timeChainOn_2} != 0) {
		/varcalc int_timeChainInterval (${int_timeChainOn_2} - ${int_timeChainOn_1})
		/varset int_timeChainInterval ${Int[${int_timeChainInterval}]}
		/cecho \ayNew Chain Interval: \aw(\ag${int_timeChainOn_2} \aw- \ag${int_timeChainOn_1}\aw) =  \ag${int_timeChainInterval}
		/varset timer_hanvar_ae ${int_timeChainInterval}s
	} else {
		/varset timer_hanvar_ae 50s
	}
	
	/varcalc chainSeconds ${timer_hanvar_ae} / 10
	/varset chainSeconds ${Int[${chainSeconds}]}
	/rs Hanvar Chains On! ${chainSeconds}s till recast!
	/call commandAttackHanvar
	/doevents flush HanvarChainsOn
/return

| Hanvar's chains wore off'
Sub Event_HanvarChainsOff
	/cecho \arChains OFF! \aw${Time.Time24} \ag${Time.SecondsSinceMidnight}
	/varset int_timeChainOff ${Time.SecondsSinceMidnight}
	/doevents flush HanvarChainsOff
/return

Sub commandAttackGuards
	/if (!${SpawnCount[npc guard radius 10]}) /return
	/cecho \ar${SpawnCount[npc guard radius 10]} \aware spawned, \ayKILLGUARDS
	/dex Xirin /target ${NearestSpawn[npc guard]}
	/dex Xirin /casting "Terror of Discord"
	/varset bln_announcedRetreat  FALSE
	/varset timer_announce_guards 10s
/return

Sub commandRetreat
	/cecho \ar${timer_hanvar_ae} (${chainSeconds})s \awuntil Hanvar AE, \aoRETREAT
	/rs HanvarRetreat ${chainSeconds}
	/varset bln_announcedRetreat TRUE
	/varset timer_announce_retreat 50s
/return 


Sub commandAttackHanvar
	/if (!${SpawnCount[npc guard  radius 10]}) /rs HanvarKill ${chainSeconds}
	/cecho \ar${timer_hanvar_ae} ${chainSeconds}s \awuntil Hanvar AE  (no guards), \agKILLHANVAR
	/varset bln_announcedRetreat  FALSE
	/varset timer_announce_kill 10s
/return

Sub EVENT_brewcheck(_line,_sender,_eventParams)
	/doevents flush  brewcheck
	/skill brewing
/return 

Sub EVENT_brewval(_line,_sender,_eventParams)
	/doevents flush  brewval
	/cecho brewVal \awLine:\ag${_line} \awSender:\ag${_sender} \aw_eventParams:\ag${_eventParams}
	/declare sval string local ${_eventParams}
	/rs Brewing: ${_eventParams}


/return
Sub getTradeskill(string _skill)
	/rs /skill ${_skill}
/return


Sub chkHeal_GroupTEST
	/echo calling chkHealGroupTest
	/declare 	i 			 	int local	0
	/declare j 		 int	local 6
	/declare s 		 int    local 0
	/declare tmr_HoT string local NULL

	


	/declare    int_majorHurt 	int local 4
	/declare    arr_majorHurt[6,2] int local 0

	/varset     arr_majorHurt[1,1] 77
	/varset     arr_majorHurt[1,2] 11212

	/varset     arr_majorHurt[4,1] 91
	/varset     arr_majorHurt[4,2] 880821

	/varset     arr_majorHurt[3,1] 20
	/varset     arr_majorHurt[3,2] 21231

	/varset     arr_majorHurt[5,1] 90
	/varset     arr_majorHurt[5,2] 45444


	/declare nonNullCount int local 0
	/declare hp1 int local 0
	/declare hp2 int local 0
	| Rigth size my non-nulls
	/declare arr_culledMajorHurt[${int_majorHurt},2] int local 0
	/declare arr_temp[1,2] int local
	/declare x int local 0
	/cecho \ay1. --------------Raw Major Hurt---------
	/for i 1 to 6
		/cecho \awRaw[${i}]: [${arr_majorHurt[${i},1]},${arr_majorHurt[${i},2]}]
		/if (${Bool[${arr_majorHurt[${i},1]}]}) {
			/varcalc x ${x}+1
			/varset arr_culledMajorHurt[${x},1] ${arr_majorHurt[${i},1]}]}
			/varset arr_culledMajorHurt[${x},2] ${arr_majorHurt[${i},2]}]}
		}
	/next i

	/cecho \ay2. --------------Culled Major Hurt---------
	/for i 1 to ${int_majorHurt}
		/cecho \aw Culled[${i}]:${arr_culledMajorHurt[${i},1]} (${arr_culledMajorHurt[${i},2]})
	/next i
	/echo -----
	/echo ${x}: ${int_majorHurt} slots are non-NULL
	/echo -----

| Sort Major Hurt
	| 77, 20, 91, 90   [20,77,90,91]
	/for i 1 to ${int_majorHurt}
		/varcalc s ${i}+1
		/echo s? ${s}
		/if (${s} > ${int_majorHurt})  /goto :printOrdered
		/for j ${s} to ${int_majorHurt}
			/varset hp1 ${arr_culledMajorHurt[${i},1]}
			/varset hp2 ${arr_culledMajorHurt[${j},1]}
			/echo hp1:${hp1} >? ${hp2}
			/if (${hp1} > ${hp2}) {
				|temp = arr[${i}]
				/cecho \aw 1. Temp = Culled[${i}]:${arr_culledMajorHurt[${i},1]} (${arr_culledMajorHurt[${i},2]})
				/varset arr_temp[1,1] ${arr_culledMajorHurt[${i},1]}
				/varset arr_temp[1,2] ${arr_culledMajorHurt[${i},2]}
				/cecho \ao 1. arr_temp[1] = ${arr_temp[1,1]} (${arr_temp[1,2]})
				|arr[${i}] = arr[${j}]
				/cecho \aw 2. Culled[${i}]:${arr_culledMajorHurt[${i},1]} (${arr_culledMajorHurt[${i},2]})= Culled[${j}]:${arr_culledMajorHurt[${j},1]} (${arr_culledMajorHurt[${j},2]})
				/varset arr_culledMajorHurt[${i},1] ${arr_culledMajorHurt[${j},1]}
				/varset arr_culledMajorHurt[${i},2] ${arr_culledMajorHurt[${j},2]}
				/cecho \ay 2. arr_culledMajorHurt[${i}]:${arr_culledMajorHurt[${i},1]} (${arr_culledMajorHurt[${i},2]})
				|arr[${j}] = temp
				/cecho \aw 3. Culled[${j}]:${arr_culledMajorHurt[${j},1]} (${arr_culledMajorHurt[${j},2]}) = ${arr_temp[1,1]} (${arr_temp[1,2]})
				/varset arr_culledMajorHurt[${j},1] ${arr_temp[1,1]}
				/varset arr_culledMajorHurt[${j},2] ${arr_temp[1,2]}
				/cecho \ar 3. arr_culledMajorHurt[${j}]:${arr_culledMajorHurt[${j},1]} (${arr_culledMajorHurt[${j},2]})
			}
		/next j
	/next i

	:printOrdered
	/cecho \ay3. --------------Ordered Major Hurt---------
	/for i 1 to ${int_majorHurt}
		/cecho \ag${i}:${arr_culledMajorHurt[${i},1]} (${arr_culledMajorHurt[${i},2]})
	/next i


/return


Sub chkDivineIntervention
	/if (${FindItemCount[Emerald]} && ${Me.SpellReady[Divine Intervention]} && !${NetBots[${Target.Name}].Buff[Divine Intervention].Name.Equal[Divine Intervention]}) {
		/say Casting Divine Intervention on ${Target.Name}!
		/call Cast "Divine Intervention"
	}
/return

Sub PrepareSpellNameForCast(string _spell)
	/declare qSpell string local
	/echo pre: ${_spell}
	/echo Find:${_spell.Left[1]}
	/varset qSpell ${_spell}
	|/if (${_spell.Left[1]})
/return ${qSpell}

Sub chkSpellMemorized(string _spell, bool _wait, _gem)
	/echo chkSpellMemorized ${_spell} ${_wait} ${_gem}
	:start
	/if (${Me.Gem[${_spell}]}) /goto :return
	/echo ${_gem.Equal[NULL]} ${_gem.Length} == 0
	/declare intGem int local 9
	/echo intGem ${intGem}
	/if (${_gem.Length} == 0) {
		/echo Gem is undefined using default
		/varset intGem  9
	} else {
		/if (${_gem.Find[gem]}) {
		/call StripGem ${_gem}
		/varset intGem ${Macro.Return}
		} else {
			/echo setting intGem to ${_gem}
			/varset intGem ${_gem}
		}
	}
	
	

	:mem
		/echo memorizing "${_spell}" ${intGem} 
		/memorize "${_spell}" ${intGem} 
		/if (!${_wait}) /goto :return
		:memwait
			/echo memwait
			/delay 10
			/if (${Me.SpellReady[${_spell}]}) /goto :return
			/goto :memwait
:return
/g returning
/return 

Sub StripGem(string _gem) 
	/echo stripping Gem ${_gem}
	/declare l int local ${_gem.Length}
	/echo ${l}
	/declare r int local ${Math.Calc[${l} - 3]} 
	/echo ${r}
	/declare intGem int local ${_gem.Right[${r}]}
	/echo intGem: ${intGem}
/return ${intGem}

Sub footest
	/echo footest
/return